/*
Hautech API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hautechapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type CallAPI interface {

	/*
	CallControllerCallAccessAttachV1 Method for CallControllerCallAccessAttachV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccessAttachV1Request
	*/
	CallControllerCallAccessAttachV1(ctx context.Context) ApiCallControllerCallAccessAttachV1Request

	// CallControllerCallAccessAttachV1Execute executes the request
	CallControllerCallAccessAttachV1Execute(r ApiCallControllerCallAccessAttachV1Request) (*http.Response, error)

	/*
	CallControllerCallAccessGrantV1 Method for CallControllerCallAccessGrantV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccessGrantV1Request
	*/
	CallControllerCallAccessGrantV1(ctx context.Context) ApiCallControllerCallAccessGrantV1Request

	// CallControllerCallAccessGrantV1Execute executes the request
	CallControllerCallAccessGrantV1Execute(r ApiCallControllerCallAccessGrantV1Request) (*http.Response, error)

	/*
	CallControllerCallAccountsBalanceAddV1 Method for CallControllerCallAccountsBalanceAddV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccountsBalanceAddV1Request
	*/
	CallControllerCallAccountsBalanceAddV1(ctx context.Context) ApiCallControllerCallAccountsBalanceAddV1Request

	// CallControllerCallAccountsBalanceAddV1Execute executes the request
	CallControllerCallAccountsBalanceAddV1Execute(r ApiCallControllerCallAccountsBalanceAddV1Request) (*http.Response, error)

	/*
	CallControllerCallAccountsBalanceGetV1 Method for CallControllerCallAccountsBalanceGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccountsBalanceGetV1Request
	*/
	CallControllerCallAccountsBalanceGetV1(ctx context.Context) ApiCallControllerCallAccountsBalanceGetV1Request

	// CallControllerCallAccountsBalanceGetV1Execute executes the request
	//  @return BalanceResultDto
	CallControllerCallAccountsBalanceGetV1Execute(r ApiCallControllerCallAccountsBalanceGetV1Request) (*BalanceResultDto, *http.Response, error)

	/*
	CallControllerCallAccountsBalanceSelfV1 Method for CallControllerCallAccountsBalanceSelfV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccountsBalanceSelfV1Request
	*/
	CallControllerCallAccountsBalanceSelfV1(ctx context.Context) ApiCallControllerCallAccountsBalanceSelfV1Request

	// CallControllerCallAccountsBalanceSelfV1Execute executes the request
	//  @return BalanceResultDto
	CallControllerCallAccountsBalanceSelfV1Execute(r ApiCallControllerCallAccountsBalanceSelfV1Request) (*BalanceResultDto, *http.Response, error)

	/*
	CallControllerCallAccountsCreateV1 Method for CallControllerCallAccountsCreateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccountsCreateV1Request
	*/
	CallControllerCallAccountsCreateV1(ctx context.Context) ApiCallControllerCallAccountsCreateV1Request

	// CallControllerCallAccountsCreateV1Execute executes the request
	//  @return AccountEntity
	CallControllerCallAccountsCreateV1Execute(r ApiCallControllerCallAccountsCreateV1Request) (*AccountEntity, *http.Response, error)

	/*
	CallControllerCallAccountsGetV1 Method for CallControllerCallAccountsGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccountsGetV1Request
	*/
	CallControllerCallAccountsGetV1(ctx context.Context) ApiCallControllerCallAccountsGetV1Request

	// CallControllerCallAccountsGetV1Execute executes the request
	//  @return AccountEntity
	CallControllerCallAccountsGetV1Execute(r ApiCallControllerCallAccountsGetV1Request) (*AccountEntity, *http.Response, error)

	/*
	CallControllerCallAccountsListV1 Method for CallControllerCallAccountsListV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccountsListV1Request
	*/
	CallControllerCallAccountsListV1(ctx context.Context) ApiCallControllerCallAccountsListV1Request

	// CallControllerCallAccountsListV1Execute executes the request
	//  @return ListAccountsDto
	CallControllerCallAccountsListV1Execute(r ApiCallControllerCallAccountsListV1Request) (*ListAccountsDto, *http.Response, error)

	/*
	CallControllerCallAccountsSelfV1 Method for CallControllerCallAccountsSelfV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallAccountsSelfV1Request
	*/
	CallControllerCallAccountsSelfV1(ctx context.Context) ApiCallControllerCallAccountsSelfV1Request

	// CallControllerCallAccountsSelfV1Execute executes the request
	//  @return AccountEntity
	CallControllerCallAccountsSelfV1Execute(r ApiCallControllerCallAccountsSelfV1Request) (*AccountEntity, *http.Response, error)

	/*
	CallControllerCallCollectionsCreateV1 Method for CallControllerCallCollectionsCreateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallCollectionsCreateV1Request
	*/
	CallControllerCallCollectionsCreateV1(ctx context.Context) ApiCallControllerCallCollectionsCreateV1Request

	// CallControllerCallCollectionsCreateV1Execute executes the request
	//  @return CollectionEntity
	CallControllerCallCollectionsCreateV1Execute(r ApiCallControllerCallCollectionsCreateV1Request) (*CollectionEntity, *http.Response, error)

	/*
	CallControllerCallCollectionsGetV1 Method for CallControllerCallCollectionsGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallCollectionsGetV1Request
	*/
	CallControllerCallCollectionsGetV1(ctx context.Context) ApiCallControllerCallCollectionsGetV1Request

	// CallControllerCallCollectionsGetV1Execute executes the request
	//  @return CollectionEntity
	CallControllerCallCollectionsGetV1Execute(r ApiCallControllerCallCollectionsGetV1Request) (*CollectionEntity, *http.Response, error)

	/*
	CallControllerCallCollectionsItemsAddV1 Method for CallControllerCallCollectionsItemsAddV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallCollectionsItemsAddV1Request
	*/
	CallControllerCallCollectionsItemsAddV1(ctx context.Context) ApiCallControllerCallCollectionsItemsAddV1Request

	// CallControllerCallCollectionsItemsAddV1Execute executes the request
	CallControllerCallCollectionsItemsAddV1Execute(r ApiCallControllerCallCollectionsItemsAddV1Request) (*http.Response, error)

	/*
	CallControllerCallCollectionsItemsListV1 Method for CallControllerCallCollectionsItemsListV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallCollectionsItemsListV1Request
	*/
	CallControllerCallCollectionsItemsListV1(ctx context.Context) ApiCallControllerCallCollectionsItemsListV1Request

	// CallControllerCallCollectionsItemsListV1Execute executes the request
	//  @return ListCollectionItemsDto
	CallControllerCallCollectionsItemsListV1Execute(r ApiCallControllerCallCollectionsItemsListV1Request) (*ListCollectionItemsDto, *http.Response, error)

	/*
	CallControllerCallCollectionsItemsRemoveV1 Method for CallControllerCallCollectionsItemsRemoveV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallCollectionsItemsRemoveV1Request
	*/
	CallControllerCallCollectionsItemsRemoveV1(ctx context.Context) ApiCallControllerCallCollectionsItemsRemoveV1Request

	// CallControllerCallCollectionsItemsRemoveV1Execute executes the request
	CallControllerCallCollectionsItemsRemoveV1Execute(r ApiCallControllerCallCollectionsItemsRemoveV1Request) (*http.Response, error)

	/*
	CallControllerCallCollectionsListV1 Method for CallControllerCallCollectionsListV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallCollectionsListV1Request
	*/
	CallControllerCallCollectionsListV1(ctx context.Context) ApiCallControllerCallCollectionsListV1Request

	// CallControllerCallCollectionsListV1Execute executes the request
	//  @return ListCollectionsDto
	CallControllerCallCollectionsListV1Execute(r ApiCallControllerCallCollectionsListV1Request) (*ListCollectionsDto, *http.Response, error)

	/*
	CallControllerCallCollectionsMetadataUpdateV1 Method for CallControllerCallCollectionsMetadataUpdateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallCollectionsMetadataUpdateV1Request
	*/
	CallControllerCallCollectionsMetadataUpdateV1(ctx context.Context) ApiCallControllerCallCollectionsMetadataUpdateV1Request

	// CallControllerCallCollectionsMetadataUpdateV1Execute executes the request
	//  @return CollectionEntity
	CallControllerCallCollectionsMetadataUpdateV1Execute(r ApiCallControllerCallCollectionsMetadataUpdateV1Request) (*CollectionEntity, *http.Response, error)

	/*
	CallControllerCallGroupsAccountsAddV1 Method for CallControllerCallGroupsAccountsAddV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallGroupsAccountsAddV1Request
	*/
	CallControllerCallGroupsAccountsAddV1(ctx context.Context) ApiCallControllerCallGroupsAccountsAddV1Request

	// CallControllerCallGroupsAccountsAddV1Execute executes the request
	CallControllerCallGroupsAccountsAddV1Execute(r ApiCallControllerCallGroupsAccountsAddV1Request) (*http.Response, error)

	/*
	CallControllerCallGroupsAccountsRemoveV1 Method for CallControllerCallGroupsAccountsRemoveV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallGroupsAccountsRemoveV1Request
	*/
	CallControllerCallGroupsAccountsRemoveV1(ctx context.Context) ApiCallControllerCallGroupsAccountsRemoveV1Request

	// CallControllerCallGroupsAccountsRemoveV1Execute executes the request
	CallControllerCallGroupsAccountsRemoveV1Execute(r ApiCallControllerCallGroupsAccountsRemoveV1Request) (*http.Response, error)

	/*
	CallControllerCallGroupsCreateV1 Method for CallControllerCallGroupsCreateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallGroupsCreateV1Request
	*/
	CallControllerCallGroupsCreateV1(ctx context.Context) ApiCallControllerCallGroupsCreateV1Request

	// CallControllerCallGroupsCreateV1Execute executes the request
	//  @return GroupEntity
	CallControllerCallGroupsCreateV1Execute(r ApiCallControllerCallGroupsCreateV1Request) (*GroupEntity, *http.Response, error)

	/*
	CallControllerCallGroupsDeleteV1 Method for CallControllerCallGroupsDeleteV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallGroupsDeleteV1Request
	*/
	CallControllerCallGroupsDeleteV1(ctx context.Context) ApiCallControllerCallGroupsDeleteV1Request

	// CallControllerCallGroupsDeleteV1Execute executes the request
	CallControllerCallGroupsDeleteV1Execute(r ApiCallControllerCallGroupsDeleteV1Request) (*http.Response, error)

	/*
	CallControllerCallGroupsGetV1 Method for CallControllerCallGroupsGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallGroupsGetV1Request
	*/
	CallControllerCallGroupsGetV1(ctx context.Context) ApiCallControllerCallGroupsGetV1Request

	// CallControllerCallGroupsGetV1Execute executes the request
	//  @return GroupEntity
	CallControllerCallGroupsGetV1Execute(r ApiCallControllerCallGroupsGetV1Request) (*GroupEntity, *http.Response, error)

	/*
	CallControllerCallImagesGetManyV1 Method for CallControllerCallImagesGetManyV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallImagesGetManyV1Request
	*/
	CallControllerCallImagesGetManyV1(ctx context.Context) ApiCallControllerCallImagesGetManyV1Request

	// CallControllerCallImagesGetManyV1Execute executes the request
	//  @return []ImageUrlResponseDto
	CallControllerCallImagesGetManyV1Execute(r ApiCallControllerCallImagesGetManyV1Request) ([]ImageUrlResponseDto, *http.Response, error)

	/*
	CallControllerCallImagesGetV1 Method for CallControllerCallImagesGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallImagesGetV1Request
	*/
	CallControllerCallImagesGetV1(ctx context.Context) ApiCallControllerCallImagesGetV1Request

	// CallControllerCallImagesGetV1Execute executes the request
	//  @return ImageEntity
	CallControllerCallImagesGetV1Execute(r ApiCallControllerCallImagesGetV1Request) (*ImageEntity, *http.Response, error)

	/*
	CallControllerCallImagesRepresentationsGetV1 Method for CallControllerCallImagesRepresentationsGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallImagesRepresentationsGetV1Request
	*/
	CallControllerCallImagesRepresentationsGetV1(ctx context.Context) ApiCallControllerCallImagesRepresentationsGetV1Request

	// CallControllerCallImagesRepresentationsGetV1Execute executes the request
	//  @return ImageRepresentationResponseDto
	CallControllerCallImagesRepresentationsGetV1Execute(r ApiCallControllerCallImagesRepresentationsGetV1Request) (*ImageRepresentationResponseDto, *http.Response, error)

	/*
	CallControllerCallOperationsGetManyV1 Method for CallControllerCallOperationsGetManyV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsGetManyV1Request
	*/
	CallControllerCallOperationsGetManyV1(ctx context.Context) ApiCallControllerCallOperationsGetManyV1Request

	// CallControllerCallOperationsGetManyV1Execute executes the request
	//  @return []OperationEntity
	CallControllerCallOperationsGetManyV1Execute(r ApiCallControllerCallOperationsGetManyV1Request) ([]OperationEntity, *http.Response, error)

	/*
	CallControllerCallOperationsGetV1 Method for CallControllerCallOperationsGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsGetV1Request
	*/
	CallControllerCallOperationsGetV1(ctx context.Context) ApiCallControllerCallOperationsGetV1Request

	// CallControllerCallOperationsGetV1Execute executes the request
	//  @return OperationEntity
	CallControllerCallOperationsGetV1Execute(r ApiCallControllerCallOperationsGetV1Request) (*OperationEntity, *http.Response, error)

	/*
	CallControllerCallOperationsListV1 Method for CallControllerCallOperationsListV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsListV1Request
	*/
	CallControllerCallOperationsListV1(ctx context.Context) ApiCallControllerCallOperationsListV1Request

	// CallControllerCallOperationsListV1Execute executes the request
	//  @return ListOperationsDto
	CallControllerCallOperationsListV1Execute(r ApiCallControllerCallOperationsListV1Request) (*ListOperationsDto, *http.Response, error)

	/*
	CallControllerCallOperationsMetadataUpdateV1 Method for CallControllerCallOperationsMetadataUpdateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsMetadataUpdateV1Request
	*/
	CallControllerCallOperationsMetadataUpdateV1(ctx context.Context) ApiCallControllerCallOperationsMetadataUpdateV1Request

	// CallControllerCallOperationsMetadataUpdateV1Execute executes the request
	//  @return OperationEntity
	CallControllerCallOperationsMetadataUpdateV1Execute(r ApiCallControllerCallOperationsMetadataUpdateV1Request) (*OperationEntity, *http.Response, error)

	/*
	CallControllerCallOperationsRunCompositeV1V1 Method for CallControllerCallOperationsRunCompositeV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunCompositeV1V1Request
	*/
	CallControllerCallOperationsRunCompositeV1V1(ctx context.Context) ApiCallControllerCallOperationsRunCompositeV1V1Request

	// CallControllerCallOperationsRunCompositeV1V1Execute executes the request
	//  @return CompositeV1Response
	CallControllerCallOperationsRunCompositeV1V1Execute(r ApiCallControllerCallOperationsRunCompositeV1V1Request) (*CompositeV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunCropV1V1 Method for CallControllerCallOperationsRunCropV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunCropV1V1Request
	*/
	CallControllerCallOperationsRunCropV1V1(ctx context.Context) ApiCallControllerCallOperationsRunCropV1V1Request

	// CallControllerCallOperationsRunCropV1V1Execute executes the request
	//  @return CropV1Response
	CallControllerCallOperationsRunCropV1V1Execute(r ApiCallControllerCallOperationsRunCropV1V1Request) (*CropV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunCutV1V1 Method for CallControllerCallOperationsRunCutV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunCutV1V1Request
	*/
	CallControllerCallOperationsRunCutV1V1(ctx context.Context) ApiCallControllerCallOperationsRunCutV1V1Request

	// CallControllerCallOperationsRunCutV1V1Execute executes the request
	//  @return CutV1Response
	CallControllerCallOperationsRunCutV1V1Execute(r ApiCallControllerCallOperationsRunCutV1V1Request) (*CutV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunGptV1V1 Method for CallControllerCallOperationsRunGptV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunGptV1V1Request
	*/
	CallControllerCallOperationsRunGptV1V1(ctx context.Context) ApiCallControllerCallOperationsRunGptV1V1Request

	// CallControllerCallOperationsRunGptV1V1Execute executes the request
	//  @return GptV1Response
	CallControllerCallOperationsRunGptV1V1Execute(r ApiCallControllerCallOperationsRunGptV1V1Request) (*GptV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunHauteLindaV1V1 Method for CallControllerCallOperationsRunHauteLindaV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunHauteLindaV1V1Request
	*/
	CallControllerCallOperationsRunHauteLindaV1V1(ctx context.Context) ApiCallControllerCallOperationsRunHauteLindaV1V1Request

	// CallControllerCallOperationsRunHauteLindaV1V1Execute executes the request
	//  @return HauteLindaV1Response
	CallControllerCallOperationsRunHauteLindaV1V1Execute(r ApiCallControllerCallOperationsRunHauteLindaV1V1Request) (*HauteLindaV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunHauteNaomiV1V1 Method for CallControllerCallOperationsRunHauteNaomiV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunHauteNaomiV1V1Request
	*/
	CallControllerCallOperationsRunHauteNaomiV1V1(ctx context.Context) ApiCallControllerCallOperationsRunHauteNaomiV1V1Request

	// CallControllerCallOperationsRunHauteNaomiV1V1Execute executes the request
	//  @return HauteNaomiV1Response
	CallControllerCallOperationsRunHauteNaomiV1V1Execute(r ApiCallControllerCallOperationsRunHauteNaomiV1V1Request) (*HauteNaomiV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunImagineKateV1V1 Method for CallControllerCallOperationsRunImagineKateV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunImagineKateV1V1Request
	*/
	CallControllerCallOperationsRunImagineKateV1V1(ctx context.Context) ApiCallControllerCallOperationsRunImagineKateV1V1Request

	// CallControllerCallOperationsRunImagineKateV1V1Execute executes the request
	//  @return ImagineKateV1Response
	CallControllerCallOperationsRunImagineKateV1V1Execute(r ApiCallControllerCallOperationsRunImagineKateV1V1Request) (*ImagineKateV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunInpaintKateV1V1 Method for CallControllerCallOperationsRunInpaintKateV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunInpaintKateV1V1Request
	*/
	CallControllerCallOperationsRunInpaintKateV1V1(ctx context.Context) ApiCallControllerCallOperationsRunInpaintKateV1V1Request

	// CallControllerCallOperationsRunInpaintKateV1V1Execute executes the request
	//  @return InpaintKateV1Response
	CallControllerCallOperationsRunInpaintKateV1V1Execute(r ApiCallControllerCallOperationsRunInpaintKateV1V1Request) (*InpaintKateV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunNegateImageV1V1 Method for CallControllerCallOperationsRunNegateImageV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunNegateImageV1V1Request
	*/
	CallControllerCallOperationsRunNegateImageV1V1(ctx context.Context) ApiCallControllerCallOperationsRunNegateImageV1V1Request

	// CallControllerCallOperationsRunNegateImageV1V1Execute executes the request
	//  @return NegateImageV1Response
	CallControllerCallOperationsRunNegateImageV1V1Execute(r ApiCallControllerCallOperationsRunNegateImageV1V1Request) (*NegateImageV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunNoiseV1V1 Method for CallControllerCallOperationsRunNoiseV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunNoiseV1V1Request
	*/
	CallControllerCallOperationsRunNoiseV1V1(ctx context.Context) ApiCallControllerCallOperationsRunNoiseV1V1Request

	// CallControllerCallOperationsRunNoiseV1V1Execute executes the request
	//  @return NoiseV1Response
	CallControllerCallOperationsRunNoiseV1V1Execute(r ApiCallControllerCallOperationsRunNoiseV1V1Request) (*NoiseV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunObjectDetectionV1V1 Method for CallControllerCallOperationsRunObjectDetectionV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunObjectDetectionV1V1Request
	*/
	CallControllerCallOperationsRunObjectDetectionV1V1(ctx context.Context) ApiCallControllerCallOperationsRunObjectDetectionV1V1Request

	// CallControllerCallOperationsRunObjectDetectionV1V1Execute executes the request
	//  @return ObjectDetectionV1Response
	CallControllerCallOperationsRunObjectDetectionV1V1Execute(r ApiCallControllerCallOperationsRunObjectDetectionV1V1Request) (*ObjectDetectionV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunPoseEstimationV1V1 Method for CallControllerCallOperationsRunPoseEstimationV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunPoseEstimationV1V1Request
	*/
	CallControllerCallOperationsRunPoseEstimationV1V1(ctx context.Context) ApiCallControllerCallOperationsRunPoseEstimationV1V1Request

	// CallControllerCallOperationsRunPoseEstimationV1V1Execute executes the request
	//  @return PoseEstimationV1Response
	CallControllerCallOperationsRunPoseEstimationV1V1Execute(r ApiCallControllerCallOperationsRunPoseEstimationV1V1Request) (*PoseEstimationV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1 Method for CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request
	*/
	CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1(ctx context.Context) ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request

	// CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Execute executes the request
	//  @return SegmentAnythingEmbeddingsV1Response
	CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Execute(r ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request) (*SegmentAnythingEmbeddingsV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunSegmentAnythingMaskV1V1 Method for CallControllerCallOperationsRunSegmentAnythingMaskV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request
	*/
	CallControllerCallOperationsRunSegmentAnythingMaskV1V1(ctx context.Context) ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request

	// CallControllerCallOperationsRunSegmentAnythingMaskV1V1Execute executes the request
	//  @return SegmentAnythingMaskV1Response
	CallControllerCallOperationsRunSegmentAnythingMaskV1V1Execute(r ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request) (*SegmentAnythingMaskV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunUpscaleV1V1 Method for CallControllerCallOperationsRunUpscaleV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunUpscaleV1V1Request
	*/
	CallControllerCallOperationsRunUpscaleV1V1(ctx context.Context) ApiCallControllerCallOperationsRunUpscaleV1V1Request

	// CallControllerCallOperationsRunUpscaleV1V1Execute executes the request
	//  @return UpscaleV1Response
	CallControllerCallOperationsRunUpscaleV1V1Execute(r ApiCallControllerCallOperationsRunUpscaleV1V1Request) (*UpscaleV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsRunVtonGiseleV1V1 Method for CallControllerCallOperationsRunVtonGiseleV1V1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsRunVtonGiseleV1V1Request
	*/
	CallControllerCallOperationsRunVtonGiseleV1V1(ctx context.Context) ApiCallControllerCallOperationsRunVtonGiseleV1V1Request

	// CallControllerCallOperationsRunVtonGiseleV1V1Execute executes the request
	//  @return VtonGiseleV1Response
	CallControllerCallOperationsRunVtonGiseleV1V1Execute(r ApiCallControllerCallOperationsRunVtonGiseleV1V1Request) (*VtonGiseleV1Response, *http.Response, error)

	/*
	CallControllerCallOperationsWaitV1 Method for CallControllerCallOperationsWaitV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallOperationsWaitV1Request
	*/
	CallControllerCallOperationsWaitV1(ctx context.Context) ApiCallControllerCallOperationsWaitV1Request

	// CallControllerCallOperationsWaitV1Execute executes the request
	//  @return OperationEntity
	CallControllerCallOperationsWaitV1Execute(r ApiCallControllerCallOperationsWaitV1Request) (*OperationEntity, *http.Response, error)

	/*
	CallControllerCallPosesGetV1 Method for CallControllerCallPosesGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallPosesGetV1Request
	*/
	CallControllerCallPosesGetV1(ctx context.Context) ApiCallControllerCallPosesGetV1Request

	// CallControllerCallPosesGetV1Execute executes the request
	//  @return PoseEntity
	CallControllerCallPosesGetV1Execute(r ApiCallControllerCallPosesGetV1Request) (*PoseEntity, *http.Response, error)

	/*
	CallControllerCallPosesListV1 Method for CallControllerCallPosesListV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallPosesListV1Request
	*/
	CallControllerCallPosesListV1(ctx context.Context) ApiCallControllerCallPosesListV1Request

	// CallControllerCallPosesListV1Execute executes the request
	//  @return ListPosesDto
	CallControllerCallPosesListV1Execute(r ApiCallControllerCallPosesListV1Request) (*ListPosesDto, *http.Response, error)

	/*
	CallControllerCallPosesPreviewSetV1 Method for CallControllerCallPosesPreviewSetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallPosesPreviewSetV1Request
	*/
	CallControllerCallPosesPreviewSetV1(ctx context.Context) ApiCallControllerCallPosesPreviewSetV1Request

	// CallControllerCallPosesPreviewSetV1Execute executes the request
	CallControllerCallPosesPreviewSetV1Execute(r ApiCallControllerCallPosesPreviewSetV1Request) (*http.Response, error)

	/*
	CallControllerCallStacksCreateV1 Method for CallControllerCallStacksCreateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStacksCreateV1Request
	*/
	CallControllerCallStacksCreateV1(ctx context.Context) ApiCallControllerCallStacksCreateV1Request

	// CallControllerCallStacksCreateV1Execute executes the request
	//  @return StackEntity
	CallControllerCallStacksCreateV1Execute(r ApiCallControllerCallStacksCreateV1Request) (*StackEntity, *http.Response, error)

	/*
	CallControllerCallStacksGetV1 Method for CallControllerCallStacksGetV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStacksGetV1Request
	*/
	CallControllerCallStacksGetV1(ctx context.Context) ApiCallControllerCallStacksGetV1Request

	// CallControllerCallStacksGetV1Execute executes the request
	//  @return StackEntity
	CallControllerCallStacksGetV1Execute(r ApiCallControllerCallStacksGetV1Request) (*StackEntity, *http.Response, error)

	/*
	CallControllerCallStacksItemsAddV1 Method for CallControllerCallStacksItemsAddV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStacksItemsAddV1Request
	*/
	CallControllerCallStacksItemsAddV1(ctx context.Context) ApiCallControllerCallStacksItemsAddV1Request

	// CallControllerCallStacksItemsAddV1Execute executes the request
	//  @return StackEntity
	CallControllerCallStacksItemsAddV1Execute(r ApiCallControllerCallStacksItemsAddV1Request) (*StackEntity, *http.Response, error)

	/*
	CallControllerCallStacksItemsRemoveV1 Method for CallControllerCallStacksItemsRemoveV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStacksItemsRemoveV1Request
	*/
	CallControllerCallStacksItemsRemoveV1(ctx context.Context) ApiCallControllerCallStacksItemsRemoveV1Request

	// CallControllerCallStacksItemsRemoveV1Execute executes the request
	//  @return StackEntity
	CallControllerCallStacksItemsRemoveV1Execute(r ApiCallControllerCallStacksItemsRemoveV1Request) (*StackEntity, *http.Response, error)

	/*
	CallControllerCallStacksListV1 Method for CallControllerCallStacksListV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStacksListV1Request
	*/
	CallControllerCallStacksListV1(ctx context.Context) ApiCallControllerCallStacksListV1Request

	// CallControllerCallStacksListV1Execute executes the request
	//  @return ListStacksDto
	CallControllerCallStacksListV1Execute(r ApiCallControllerCallStacksListV1Request) (*ListStacksDto, *http.Response, error)

	/*
	CallControllerCallStacksMetadataUpdateV1 Method for CallControllerCallStacksMetadataUpdateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStacksMetadataUpdateV1Request
	*/
	CallControllerCallStacksMetadataUpdateV1(ctx context.Context) ApiCallControllerCallStacksMetadataUpdateV1Request

	// CallControllerCallStacksMetadataUpdateV1Execute executes the request
	//  @return StackEntity
	CallControllerCallStacksMetadataUpdateV1Execute(r ApiCallControllerCallStacksMetadataUpdateV1Request) (*StackEntity, *http.Response, error)

	/*
	CallControllerCallStorageCreateV1 Method for CallControllerCallStorageCreateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStorageCreateV1Request
	*/
	CallControllerCallStorageCreateV1(ctx context.Context) ApiCallControllerCallStorageCreateV1Request

	// CallControllerCallStorageCreateV1Execute executes the request
	//  @return StorageEntity
	CallControllerCallStorageCreateV1Execute(r ApiCallControllerCallStorageCreateV1Request) (*StorageEntity, *http.Response, error)

	/*
	CallControllerCallStorageDeleteV1 Method for CallControllerCallStorageDeleteV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStorageDeleteV1Request
	*/
	CallControllerCallStorageDeleteV1(ctx context.Context) ApiCallControllerCallStorageDeleteV1Request

	// CallControllerCallStorageDeleteV1Execute executes the request
	CallControllerCallStorageDeleteV1Execute(r ApiCallControllerCallStorageDeleteV1Request) (*http.Response, error)

	/*
	CallControllerCallStorageGetManyV1 Method for CallControllerCallStorageGetManyV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStorageGetManyV1Request
	*/
	CallControllerCallStorageGetManyV1(ctx context.Context) ApiCallControllerCallStorageGetManyV1Request

	// CallControllerCallStorageGetManyV1Execute executes the request
	//  @return []StorageRecordsResultDto
	CallControllerCallStorageGetManyV1Execute(r ApiCallControllerCallStorageGetManyV1Request) ([]StorageRecordsResultDto, *http.Response, error)

	/*
	CallControllerCallStorageUpdateV1 Method for CallControllerCallStorageUpdateV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCallControllerCallStorageUpdateV1Request
	*/
	CallControllerCallStorageUpdateV1(ctx context.Context) ApiCallControllerCallStorageUpdateV1Request

	// CallControllerCallStorageUpdateV1Execute executes the request
	//  @return StorageEntity
	CallControllerCallStorageUpdateV1Execute(r ApiCallControllerCallStorageUpdateV1Request) (*StorageEntity, *http.Response, error)
}

// CallAPIService CallAPI service
type CallAPIService service

type ApiCallControllerCallAccessAttachV1Request struct {
	ctx context.Context
	ApiService CallAPI
	attachAccessParamsDto *AttachAccessParamsDto
}

func (r ApiCallControllerCallAccessAttachV1Request) AttachAccessParamsDto(attachAccessParamsDto AttachAccessParamsDto) ApiCallControllerCallAccessAttachV1Request {
	r.attachAccessParamsDto = &attachAccessParamsDto
	return r
}

func (r ApiCallControllerCallAccessAttachV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallAccessAttachV1Execute(r)
}

/*
CallControllerCallAccessAttachV1 Method for CallControllerCallAccessAttachV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccessAttachV1Request
*/
func (a *CallAPIService) CallControllerCallAccessAttachV1(ctx context.Context) ApiCallControllerCallAccessAttachV1Request {
	return ApiCallControllerCallAccessAttachV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallAccessAttachV1Execute(r ApiCallControllerCallAccessAttachV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccessAttachV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/access.attach"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attachAccessParamsDto == nil {
		return nil, reportError("attachAccessParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attachAccessParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallAccessGrantV1Request struct {
	ctx context.Context
	ApiService CallAPI
	modifyAccessParamsDto *ModifyAccessParamsDto
}

func (r ApiCallControllerCallAccessGrantV1Request) ModifyAccessParamsDto(modifyAccessParamsDto ModifyAccessParamsDto) ApiCallControllerCallAccessGrantV1Request {
	r.modifyAccessParamsDto = &modifyAccessParamsDto
	return r
}

func (r ApiCallControllerCallAccessGrantV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallAccessGrantV1Execute(r)
}

/*
CallControllerCallAccessGrantV1 Method for CallControllerCallAccessGrantV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccessGrantV1Request
*/
func (a *CallAPIService) CallControllerCallAccessGrantV1(ctx context.Context) ApiCallControllerCallAccessGrantV1Request {
	return ApiCallControllerCallAccessGrantV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallAccessGrantV1Execute(r ApiCallControllerCallAccessGrantV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccessGrantV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/access.grant"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modifyAccessParamsDto == nil {
		return nil, reportError("modifyAccessParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.modifyAccessParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallAccountsBalanceAddV1Request struct {
	ctx context.Context
	ApiService CallAPI
	addBalanceParamsDto *AddBalanceParamsDto
}

func (r ApiCallControllerCallAccountsBalanceAddV1Request) AddBalanceParamsDto(addBalanceParamsDto AddBalanceParamsDto) ApiCallControllerCallAccountsBalanceAddV1Request {
	r.addBalanceParamsDto = &addBalanceParamsDto
	return r
}

func (r ApiCallControllerCallAccountsBalanceAddV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallAccountsBalanceAddV1Execute(r)
}

/*
CallControllerCallAccountsBalanceAddV1 Method for CallControllerCallAccountsBalanceAddV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccountsBalanceAddV1Request
*/
func (a *CallAPIService) CallControllerCallAccountsBalanceAddV1(ctx context.Context) ApiCallControllerCallAccountsBalanceAddV1Request {
	return ApiCallControllerCallAccountsBalanceAddV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallAccountsBalanceAddV1Execute(r ApiCallControllerCallAccountsBalanceAddV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccountsBalanceAddV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/accounts.balance.add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addBalanceParamsDto == nil {
		return nil, reportError("addBalanceParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addBalanceParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallAccountsBalanceGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getBalanceParamsDto *GetBalanceParamsDto
}

func (r ApiCallControllerCallAccountsBalanceGetV1Request) GetBalanceParamsDto(getBalanceParamsDto GetBalanceParamsDto) ApiCallControllerCallAccountsBalanceGetV1Request {
	r.getBalanceParamsDto = &getBalanceParamsDto
	return r
}

func (r ApiCallControllerCallAccountsBalanceGetV1Request) Execute() (*BalanceResultDto, *http.Response, error) {
	return r.ApiService.CallControllerCallAccountsBalanceGetV1Execute(r)
}

/*
CallControllerCallAccountsBalanceGetV1 Method for CallControllerCallAccountsBalanceGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccountsBalanceGetV1Request
*/
func (a *CallAPIService) CallControllerCallAccountsBalanceGetV1(ctx context.Context) ApiCallControllerCallAccountsBalanceGetV1Request {
	return ApiCallControllerCallAccountsBalanceGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BalanceResultDto
func (a *CallAPIService) CallControllerCallAccountsBalanceGetV1Execute(r ApiCallControllerCallAccountsBalanceGetV1Request) (*BalanceResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BalanceResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccountsBalanceGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/accounts.balance.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getBalanceParamsDto == nil {
		return localVarReturnValue, nil, reportError("getBalanceParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getBalanceParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallAccountsBalanceSelfV1Request struct {
	ctx context.Context
	ApiService CallAPI
	body *string
}

func (r ApiCallControllerCallAccountsBalanceSelfV1Request) Body(body string) ApiCallControllerCallAccountsBalanceSelfV1Request {
	r.body = &body
	return r
}

func (r ApiCallControllerCallAccountsBalanceSelfV1Request) Execute() (*BalanceResultDto, *http.Response, error) {
	return r.ApiService.CallControllerCallAccountsBalanceSelfV1Execute(r)
}

/*
CallControllerCallAccountsBalanceSelfV1 Method for CallControllerCallAccountsBalanceSelfV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccountsBalanceSelfV1Request
*/
func (a *CallAPIService) CallControllerCallAccountsBalanceSelfV1(ctx context.Context) ApiCallControllerCallAccountsBalanceSelfV1Request {
	return ApiCallControllerCallAccountsBalanceSelfV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BalanceResultDto
func (a *CallAPIService) CallControllerCallAccountsBalanceSelfV1Execute(r ApiCallControllerCallAccountsBalanceSelfV1Request) (*BalanceResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BalanceResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccountsBalanceSelfV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/accounts.balance.self"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallAccountsCreateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	createAccountParamsDto *CreateAccountParamsDto
}

func (r ApiCallControllerCallAccountsCreateV1Request) CreateAccountParamsDto(createAccountParamsDto CreateAccountParamsDto) ApiCallControllerCallAccountsCreateV1Request {
	r.createAccountParamsDto = &createAccountParamsDto
	return r
}

func (r ApiCallControllerCallAccountsCreateV1Request) Execute() (*AccountEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallAccountsCreateV1Execute(r)
}

/*
CallControllerCallAccountsCreateV1 Method for CallControllerCallAccountsCreateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccountsCreateV1Request
*/
func (a *CallAPIService) CallControllerCallAccountsCreateV1(ctx context.Context) ApiCallControllerCallAccountsCreateV1Request {
	return ApiCallControllerCallAccountsCreateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountEntity
func (a *CallAPIService) CallControllerCallAccountsCreateV1Execute(r ApiCallControllerCallAccountsCreateV1Request) (*AccountEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccountsCreateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/accounts.create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountParamsDto == nil {
		return localVarReturnValue, nil, reportError("createAccountParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallAccountsGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getAccountParamsDto *GetAccountParamsDto
}

func (r ApiCallControllerCallAccountsGetV1Request) GetAccountParamsDto(getAccountParamsDto GetAccountParamsDto) ApiCallControllerCallAccountsGetV1Request {
	r.getAccountParamsDto = &getAccountParamsDto
	return r
}

func (r ApiCallControllerCallAccountsGetV1Request) Execute() (*AccountEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallAccountsGetV1Execute(r)
}

/*
CallControllerCallAccountsGetV1 Method for CallControllerCallAccountsGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccountsGetV1Request
*/
func (a *CallAPIService) CallControllerCallAccountsGetV1(ctx context.Context) ApiCallControllerCallAccountsGetV1Request {
	return ApiCallControllerCallAccountsGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountEntity
func (a *CallAPIService) CallControllerCallAccountsGetV1Execute(r ApiCallControllerCallAccountsGetV1Request) (*AccountEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccountsGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/accounts.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getAccountParamsDto == nil {
		return localVarReturnValue, nil, reportError("getAccountParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getAccountParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallAccountsListV1Request struct {
	ctx context.Context
	ApiService CallAPI
	listAccountsParamsDto *ListAccountsParamsDto
}

func (r ApiCallControllerCallAccountsListV1Request) ListAccountsParamsDto(listAccountsParamsDto ListAccountsParamsDto) ApiCallControllerCallAccountsListV1Request {
	r.listAccountsParamsDto = &listAccountsParamsDto
	return r
}

func (r ApiCallControllerCallAccountsListV1Request) Execute() (*ListAccountsDto, *http.Response, error) {
	return r.ApiService.CallControllerCallAccountsListV1Execute(r)
}

/*
CallControllerCallAccountsListV1 Method for CallControllerCallAccountsListV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccountsListV1Request
*/
func (a *CallAPIService) CallControllerCallAccountsListV1(ctx context.Context) ApiCallControllerCallAccountsListV1Request {
	return ApiCallControllerCallAccountsListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAccountsDto
func (a *CallAPIService) CallControllerCallAccountsListV1Execute(r ApiCallControllerCallAccountsListV1Request) (*ListAccountsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAccountsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccountsListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/accounts.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listAccountsParamsDto == nil {
		return localVarReturnValue, nil, reportError("listAccountsParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listAccountsParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallAccountsSelfV1Request struct {
	ctx context.Context
	ApiService CallAPI
	body *string
}

func (r ApiCallControllerCallAccountsSelfV1Request) Body(body string) ApiCallControllerCallAccountsSelfV1Request {
	r.body = &body
	return r
}

func (r ApiCallControllerCallAccountsSelfV1Request) Execute() (*AccountEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallAccountsSelfV1Execute(r)
}

/*
CallControllerCallAccountsSelfV1 Method for CallControllerCallAccountsSelfV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallAccountsSelfV1Request
*/
func (a *CallAPIService) CallControllerCallAccountsSelfV1(ctx context.Context) ApiCallControllerCallAccountsSelfV1Request {
	return ApiCallControllerCallAccountsSelfV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountEntity
func (a *CallAPIService) CallControllerCallAccountsSelfV1Execute(r ApiCallControllerCallAccountsSelfV1Request) (*AccountEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallAccountsSelfV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/accounts.self"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallCollectionsCreateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	createCollectionParamsDto *CreateCollectionParamsDto
}

func (r ApiCallControllerCallCollectionsCreateV1Request) CreateCollectionParamsDto(createCollectionParamsDto CreateCollectionParamsDto) ApiCallControllerCallCollectionsCreateV1Request {
	r.createCollectionParamsDto = &createCollectionParamsDto
	return r
}

func (r ApiCallControllerCallCollectionsCreateV1Request) Execute() (*CollectionEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallCollectionsCreateV1Execute(r)
}

/*
CallControllerCallCollectionsCreateV1 Method for CallControllerCallCollectionsCreateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallCollectionsCreateV1Request
*/
func (a *CallAPIService) CallControllerCallCollectionsCreateV1(ctx context.Context) ApiCallControllerCallCollectionsCreateV1Request {
	return ApiCallControllerCallCollectionsCreateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionEntity
func (a *CallAPIService) CallControllerCallCollectionsCreateV1Execute(r ApiCallControllerCallCollectionsCreateV1Request) (*CollectionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallCollectionsCreateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/collections.create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCollectionParamsDto == nil {
		return localVarReturnValue, nil, reportError("createCollectionParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCollectionParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallCollectionsGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getCollectionParamsDto *GetCollectionParamsDto
}

func (r ApiCallControllerCallCollectionsGetV1Request) GetCollectionParamsDto(getCollectionParamsDto GetCollectionParamsDto) ApiCallControllerCallCollectionsGetV1Request {
	r.getCollectionParamsDto = &getCollectionParamsDto
	return r
}

func (r ApiCallControllerCallCollectionsGetV1Request) Execute() (*CollectionEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallCollectionsGetV1Execute(r)
}

/*
CallControllerCallCollectionsGetV1 Method for CallControllerCallCollectionsGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallCollectionsGetV1Request
*/
func (a *CallAPIService) CallControllerCallCollectionsGetV1(ctx context.Context) ApiCallControllerCallCollectionsGetV1Request {
	return ApiCallControllerCallCollectionsGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionEntity
func (a *CallAPIService) CallControllerCallCollectionsGetV1Execute(r ApiCallControllerCallCollectionsGetV1Request) (*CollectionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallCollectionsGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/collections.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getCollectionParamsDto == nil {
		return localVarReturnValue, nil, reportError("getCollectionParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getCollectionParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallCollectionsItemsAddV1Request struct {
	ctx context.Context
	ApiService CallAPI
	addItemsToCollectionParamsDto *AddItemsToCollectionParamsDto
}

func (r ApiCallControllerCallCollectionsItemsAddV1Request) AddItemsToCollectionParamsDto(addItemsToCollectionParamsDto AddItemsToCollectionParamsDto) ApiCallControllerCallCollectionsItemsAddV1Request {
	r.addItemsToCollectionParamsDto = &addItemsToCollectionParamsDto
	return r
}

func (r ApiCallControllerCallCollectionsItemsAddV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallCollectionsItemsAddV1Execute(r)
}

/*
CallControllerCallCollectionsItemsAddV1 Method for CallControllerCallCollectionsItemsAddV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallCollectionsItemsAddV1Request
*/
func (a *CallAPIService) CallControllerCallCollectionsItemsAddV1(ctx context.Context) ApiCallControllerCallCollectionsItemsAddV1Request {
	return ApiCallControllerCallCollectionsItemsAddV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallCollectionsItemsAddV1Execute(r ApiCallControllerCallCollectionsItemsAddV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallCollectionsItemsAddV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/collections.items.add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addItemsToCollectionParamsDto == nil {
		return nil, reportError("addItemsToCollectionParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addItemsToCollectionParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallCollectionsItemsListV1Request struct {
	ctx context.Context
	ApiService CallAPI
	listCollectionItemsParamsDto *ListCollectionItemsParamsDto
}

func (r ApiCallControllerCallCollectionsItemsListV1Request) ListCollectionItemsParamsDto(listCollectionItemsParamsDto ListCollectionItemsParamsDto) ApiCallControllerCallCollectionsItemsListV1Request {
	r.listCollectionItemsParamsDto = &listCollectionItemsParamsDto
	return r
}

func (r ApiCallControllerCallCollectionsItemsListV1Request) Execute() (*ListCollectionItemsDto, *http.Response, error) {
	return r.ApiService.CallControllerCallCollectionsItemsListV1Execute(r)
}

/*
CallControllerCallCollectionsItemsListV1 Method for CallControllerCallCollectionsItemsListV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallCollectionsItemsListV1Request
*/
func (a *CallAPIService) CallControllerCallCollectionsItemsListV1(ctx context.Context) ApiCallControllerCallCollectionsItemsListV1Request {
	return ApiCallControllerCallCollectionsItemsListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListCollectionItemsDto
func (a *CallAPIService) CallControllerCallCollectionsItemsListV1Execute(r ApiCallControllerCallCollectionsItemsListV1Request) (*ListCollectionItemsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCollectionItemsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallCollectionsItemsListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/collections.items.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listCollectionItemsParamsDto == nil {
		return localVarReturnValue, nil, reportError("listCollectionItemsParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listCollectionItemsParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallCollectionsItemsRemoveV1Request struct {
	ctx context.Context
	ApiService CallAPI
	removeItemsFromCollectionParamsDto *RemoveItemsFromCollectionParamsDto
}

func (r ApiCallControllerCallCollectionsItemsRemoveV1Request) RemoveItemsFromCollectionParamsDto(removeItemsFromCollectionParamsDto RemoveItemsFromCollectionParamsDto) ApiCallControllerCallCollectionsItemsRemoveV1Request {
	r.removeItemsFromCollectionParamsDto = &removeItemsFromCollectionParamsDto
	return r
}

func (r ApiCallControllerCallCollectionsItemsRemoveV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallCollectionsItemsRemoveV1Execute(r)
}

/*
CallControllerCallCollectionsItemsRemoveV1 Method for CallControllerCallCollectionsItemsRemoveV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallCollectionsItemsRemoveV1Request
*/
func (a *CallAPIService) CallControllerCallCollectionsItemsRemoveV1(ctx context.Context) ApiCallControllerCallCollectionsItemsRemoveV1Request {
	return ApiCallControllerCallCollectionsItemsRemoveV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallCollectionsItemsRemoveV1Execute(r ApiCallControllerCallCollectionsItemsRemoveV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallCollectionsItemsRemoveV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/collections.items.remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeItemsFromCollectionParamsDto == nil {
		return nil, reportError("removeItemsFromCollectionParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeItemsFromCollectionParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallCollectionsListV1Request struct {
	ctx context.Context
	ApiService CallAPI
	listCollectionsParamsDto *ListCollectionsParamsDto
}

func (r ApiCallControllerCallCollectionsListV1Request) ListCollectionsParamsDto(listCollectionsParamsDto ListCollectionsParamsDto) ApiCallControllerCallCollectionsListV1Request {
	r.listCollectionsParamsDto = &listCollectionsParamsDto
	return r
}

func (r ApiCallControllerCallCollectionsListV1Request) Execute() (*ListCollectionsDto, *http.Response, error) {
	return r.ApiService.CallControllerCallCollectionsListV1Execute(r)
}

/*
CallControllerCallCollectionsListV1 Method for CallControllerCallCollectionsListV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallCollectionsListV1Request
*/
func (a *CallAPIService) CallControllerCallCollectionsListV1(ctx context.Context) ApiCallControllerCallCollectionsListV1Request {
	return ApiCallControllerCallCollectionsListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListCollectionsDto
func (a *CallAPIService) CallControllerCallCollectionsListV1Execute(r ApiCallControllerCallCollectionsListV1Request) (*ListCollectionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCollectionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallCollectionsListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/collections.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listCollectionsParamsDto == nil {
		return localVarReturnValue, nil, reportError("listCollectionsParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listCollectionsParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallCollectionsMetadataUpdateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	updateResourceMetadataDto *UpdateResourceMetadataDto
}

func (r ApiCallControllerCallCollectionsMetadataUpdateV1Request) UpdateResourceMetadataDto(updateResourceMetadataDto UpdateResourceMetadataDto) ApiCallControllerCallCollectionsMetadataUpdateV1Request {
	r.updateResourceMetadataDto = &updateResourceMetadataDto
	return r
}

func (r ApiCallControllerCallCollectionsMetadataUpdateV1Request) Execute() (*CollectionEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallCollectionsMetadataUpdateV1Execute(r)
}

/*
CallControllerCallCollectionsMetadataUpdateV1 Method for CallControllerCallCollectionsMetadataUpdateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallCollectionsMetadataUpdateV1Request
*/
func (a *CallAPIService) CallControllerCallCollectionsMetadataUpdateV1(ctx context.Context) ApiCallControllerCallCollectionsMetadataUpdateV1Request {
	return ApiCallControllerCallCollectionsMetadataUpdateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionEntity
func (a *CallAPIService) CallControllerCallCollectionsMetadataUpdateV1Execute(r ApiCallControllerCallCollectionsMetadataUpdateV1Request) (*CollectionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallCollectionsMetadataUpdateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/collections.metadata.update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateResourceMetadataDto == nil {
		return localVarReturnValue, nil, reportError("updateResourceMetadataDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateResourceMetadataDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallGroupsAccountsAddV1Request struct {
	ctx context.Context
	ApiService CallAPI
	addAccountToGroupParamsDto *AddAccountToGroupParamsDto
}

func (r ApiCallControllerCallGroupsAccountsAddV1Request) AddAccountToGroupParamsDto(addAccountToGroupParamsDto AddAccountToGroupParamsDto) ApiCallControllerCallGroupsAccountsAddV1Request {
	r.addAccountToGroupParamsDto = &addAccountToGroupParamsDto
	return r
}

func (r ApiCallControllerCallGroupsAccountsAddV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallGroupsAccountsAddV1Execute(r)
}

/*
CallControllerCallGroupsAccountsAddV1 Method for CallControllerCallGroupsAccountsAddV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallGroupsAccountsAddV1Request
*/
func (a *CallAPIService) CallControllerCallGroupsAccountsAddV1(ctx context.Context) ApiCallControllerCallGroupsAccountsAddV1Request {
	return ApiCallControllerCallGroupsAccountsAddV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallGroupsAccountsAddV1Execute(r ApiCallControllerCallGroupsAccountsAddV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallGroupsAccountsAddV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/groups.accounts.add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addAccountToGroupParamsDto == nil {
		return nil, reportError("addAccountToGroupParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addAccountToGroupParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallGroupsAccountsRemoveV1Request struct {
	ctx context.Context
	ApiService CallAPI
	removeAccountFromGroupParamsDto *RemoveAccountFromGroupParamsDto
}

func (r ApiCallControllerCallGroupsAccountsRemoveV1Request) RemoveAccountFromGroupParamsDto(removeAccountFromGroupParamsDto RemoveAccountFromGroupParamsDto) ApiCallControllerCallGroupsAccountsRemoveV1Request {
	r.removeAccountFromGroupParamsDto = &removeAccountFromGroupParamsDto
	return r
}

func (r ApiCallControllerCallGroupsAccountsRemoveV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallGroupsAccountsRemoveV1Execute(r)
}

/*
CallControllerCallGroupsAccountsRemoveV1 Method for CallControllerCallGroupsAccountsRemoveV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallGroupsAccountsRemoveV1Request
*/
func (a *CallAPIService) CallControllerCallGroupsAccountsRemoveV1(ctx context.Context) ApiCallControllerCallGroupsAccountsRemoveV1Request {
	return ApiCallControllerCallGroupsAccountsRemoveV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallGroupsAccountsRemoveV1Execute(r ApiCallControllerCallGroupsAccountsRemoveV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallGroupsAccountsRemoveV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/groups.accounts.remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeAccountFromGroupParamsDto == nil {
		return nil, reportError("removeAccountFromGroupParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeAccountFromGroupParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallGroupsCreateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	body *string
}

func (r ApiCallControllerCallGroupsCreateV1Request) Body(body string) ApiCallControllerCallGroupsCreateV1Request {
	r.body = &body
	return r
}

func (r ApiCallControllerCallGroupsCreateV1Request) Execute() (*GroupEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallGroupsCreateV1Execute(r)
}

/*
CallControllerCallGroupsCreateV1 Method for CallControllerCallGroupsCreateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallGroupsCreateV1Request
*/
func (a *CallAPIService) CallControllerCallGroupsCreateV1(ctx context.Context) ApiCallControllerCallGroupsCreateV1Request {
	return ApiCallControllerCallGroupsCreateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GroupEntity
func (a *CallAPIService) CallControllerCallGroupsCreateV1Execute(r ApiCallControllerCallGroupsCreateV1Request) (*GroupEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallGroupsCreateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/groups.create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallGroupsDeleteV1Request struct {
	ctx context.Context
	ApiService CallAPI
	deleteParamsDto *DeleteParamsDto
}

func (r ApiCallControllerCallGroupsDeleteV1Request) DeleteParamsDto(deleteParamsDto DeleteParamsDto) ApiCallControllerCallGroupsDeleteV1Request {
	r.deleteParamsDto = &deleteParamsDto
	return r
}

func (r ApiCallControllerCallGroupsDeleteV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallGroupsDeleteV1Execute(r)
}

/*
CallControllerCallGroupsDeleteV1 Method for CallControllerCallGroupsDeleteV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallGroupsDeleteV1Request
*/
func (a *CallAPIService) CallControllerCallGroupsDeleteV1(ctx context.Context) ApiCallControllerCallGroupsDeleteV1Request {
	return ApiCallControllerCallGroupsDeleteV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallGroupsDeleteV1Execute(r ApiCallControllerCallGroupsDeleteV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallGroupsDeleteV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/groups.delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteParamsDto == nil {
		return nil, reportError("deleteParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallGroupsGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getGroupParamsDto *GetGroupParamsDto
}

func (r ApiCallControllerCallGroupsGetV1Request) GetGroupParamsDto(getGroupParamsDto GetGroupParamsDto) ApiCallControllerCallGroupsGetV1Request {
	r.getGroupParamsDto = &getGroupParamsDto
	return r
}

func (r ApiCallControllerCallGroupsGetV1Request) Execute() (*GroupEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallGroupsGetV1Execute(r)
}

/*
CallControllerCallGroupsGetV1 Method for CallControllerCallGroupsGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallGroupsGetV1Request
*/
func (a *CallAPIService) CallControllerCallGroupsGetV1(ctx context.Context) ApiCallControllerCallGroupsGetV1Request {
	return ApiCallControllerCallGroupsGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GroupEntity
func (a *CallAPIService) CallControllerCallGroupsGetV1Execute(r ApiCallControllerCallGroupsGetV1Request) (*GroupEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GroupEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallGroupsGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/groups.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getGroupParamsDto == nil {
		return localVarReturnValue, nil, reportError("getGroupParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getGroupParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallImagesGetManyV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getUrlsForImagesParamsDto *GetUrlsForImagesParamsDto
}

func (r ApiCallControllerCallImagesGetManyV1Request) GetUrlsForImagesParamsDto(getUrlsForImagesParamsDto GetUrlsForImagesParamsDto) ApiCallControllerCallImagesGetManyV1Request {
	r.getUrlsForImagesParamsDto = &getUrlsForImagesParamsDto
	return r
}

func (r ApiCallControllerCallImagesGetManyV1Request) Execute() ([]ImageUrlResponseDto, *http.Response, error) {
	return r.ApiService.CallControllerCallImagesGetManyV1Execute(r)
}

/*
CallControllerCallImagesGetManyV1 Method for CallControllerCallImagesGetManyV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallImagesGetManyV1Request
*/
func (a *CallAPIService) CallControllerCallImagesGetManyV1(ctx context.Context) ApiCallControllerCallImagesGetManyV1Request {
	return ApiCallControllerCallImagesGetManyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ImageUrlResponseDto
func (a *CallAPIService) CallControllerCallImagesGetManyV1Execute(r ApiCallControllerCallImagesGetManyV1Request) ([]ImageUrlResponseDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ImageUrlResponseDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallImagesGetManyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/images.getMany"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getUrlsForImagesParamsDto == nil {
		return localVarReturnValue, nil, reportError("getUrlsForImagesParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getUrlsForImagesParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallImagesGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getImageParamsDto *GetImageParamsDto
}

func (r ApiCallControllerCallImagesGetV1Request) GetImageParamsDto(getImageParamsDto GetImageParamsDto) ApiCallControllerCallImagesGetV1Request {
	r.getImageParamsDto = &getImageParamsDto
	return r
}

func (r ApiCallControllerCallImagesGetV1Request) Execute() (*ImageEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallImagesGetV1Execute(r)
}

/*
CallControllerCallImagesGetV1 Method for CallControllerCallImagesGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallImagesGetV1Request
*/
func (a *CallAPIService) CallControllerCallImagesGetV1(ctx context.Context) ApiCallControllerCallImagesGetV1Request {
	return ApiCallControllerCallImagesGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImageEntity
func (a *CallAPIService) CallControllerCallImagesGetV1Execute(r ApiCallControllerCallImagesGetV1Request) (*ImageEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallImagesGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/images.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getImageParamsDto == nil {
		return localVarReturnValue, nil, reportError("getImageParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getImageParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallImagesRepresentationsGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getImageRepresentationParamsDto *GetImageRepresentationParamsDto
}

func (r ApiCallControllerCallImagesRepresentationsGetV1Request) GetImageRepresentationParamsDto(getImageRepresentationParamsDto GetImageRepresentationParamsDto) ApiCallControllerCallImagesRepresentationsGetV1Request {
	r.getImageRepresentationParamsDto = &getImageRepresentationParamsDto
	return r
}

func (r ApiCallControllerCallImagesRepresentationsGetV1Request) Execute() (*ImageRepresentationResponseDto, *http.Response, error) {
	return r.ApiService.CallControllerCallImagesRepresentationsGetV1Execute(r)
}

/*
CallControllerCallImagesRepresentationsGetV1 Method for CallControllerCallImagesRepresentationsGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallImagesRepresentationsGetV1Request
*/
func (a *CallAPIService) CallControllerCallImagesRepresentationsGetV1(ctx context.Context) ApiCallControllerCallImagesRepresentationsGetV1Request {
	return ApiCallControllerCallImagesRepresentationsGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImageRepresentationResponseDto
func (a *CallAPIService) CallControllerCallImagesRepresentationsGetV1Execute(r ApiCallControllerCallImagesRepresentationsGetV1Request) (*ImageRepresentationResponseDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageRepresentationResponseDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallImagesRepresentationsGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/images.representations.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getImageRepresentationParamsDto == nil {
		return localVarReturnValue, nil, reportError("getImageRepresentationParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getImageRepresentationParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsGetManyV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getOperationsParamsDto *GetOperationsParamsDto
}

func (r ApiCallControllerCallOperationsGetManyV1Request) GetOperationsParamsDto(getOperationsParamsDto GetOperationsParamsDto) ApiCallControllerCallOperationsGetManyV1Request {
	r.getOperationsParamsDto = &getOperationsParamsDto
	return r
}

func (r ApiCallControllerCallOperationsGetManyV1Request) Execute() ([]OperationEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsGetManyV1Execute(r)
}

/*
CallControllerCallOperationsGetManyV1 Method for CallControllerCallOperationsGetManyV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsGetManyV1Request
*/
func (a *CallAPIService) CallControllerCallOperationsGetManyV1(ctx context.Context) ApiCallControllerCallOperationsGetManyV1Request {
	return ApiCallControllerCallOperationsGetManyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OperationEntity
func (a *CallAPIService) CallControllerCallOperationsGetManyV1Execute(r ApiCallControllerCallOperationsGetManyV1Request) ([]OperationEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OperationEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsGetManyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.getMany"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getOperationsParamsDto == nil {
		return localVarReturnValue, nil, reportError("getOperationsParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getOperationsParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getOperationParamsDto *GetOperationParamsDto
}

func (r ApiCallControllerCallOperationsGetV1Request) GetOperationParamsDto(getOperationParamsDto GetOperationParamsDto) ApiCallControllerCallOperationsGetV1Request {
	r.getOperationParamsDto = &getOperationParamsDto
	return r
}

func (r ApiCallControllerCallOperationsGetV1Request) Execute() (*OperationEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsGetV1Execute(r)
}

/*
CallControllerCallOperationsGetV1 Method for CallControllerCallOperationsGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsGetV1Request
*/
func (a *CallAPIService) CallControllerCallOperationsGetV1(ctx context.Context) ApiCallControllerCallOperationsGetV1Request {
	return ApiCallControllerCallOperationsGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperationEntity
func (a *CallAPIService) CallControllerCallOperationsGetV1Execute(r ApiCallControllerCallOperationsGetV1Request) (*OperationEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperationEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getOperationParamsDto == nil {
		return localVarReturnValue, nil, reportError("getOperationParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getOperationParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsListV1Request struct {
	ctx context.Context
	ApiService CallAPI
	listOperationsParamsDto *ListOperationsParamsDto
}

func (r ApiCallControllerCallOperationsListV1Request) ListOperationsParamsDto(listOperationsParamsDto ListOperationsParamsDto) ApiCallControllerCallOperationsListV1Request {
	r.listOperationsParamsDto = &listOperationsParamsDto
	return r
}

func (r ApiCallControllerCallOperationsListV1Request) Execute() (*ListOperationsDto, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsListV1Execute(r)
}

/*
CallControllerCallOperationsListV1 Method for CallControllerCallOperationsListV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsListV1Request
*/
func (a *CallAPIService) CallControllerCallOperationsListV1(ctx context.Context) ApiCallControllerCallOperationsListV1Request {
	return ApiCallControllerCallOperationsListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOperationsDto
func (a *CallAPIService) CallControllerCallOperationsListV1Execute(r ApiCallControllerCallOperationsListV1Request) (*ListOperationsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOperationsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listOperationsParamsDto == nil {
		return localVarReturnValue, nil, reportError("listOperationsParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listOperationsParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsMetadataUpdateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	updateResourceMetadataDto *UpdateResourceMetadataDto
}

func (r ApiCallControllerCallOperationsMetadataUpdateV1Request) UpdateResourceMetadataDto(updateResourceMetadataDto UpdateResourceMetadataDto) ApiCallControllerCallOperationsMetadataUpdateV1Request {
	r.updateResourceMetadataDto = &updateResourceMetadataDto
	return r
}

func (r ApiCallControllerCallOperationsMetadataUpdateV1Request) Execute() (*OperationEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsMetadataUpdateV1Execute(r)
}

/*
CallControllerCallOperationsMetadataUpdateV1 Method for CallControllerCallOperationsMetadataUpdateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsMetadataUpdateV1Request
*/
func (a *CallAPIService) CallControllerCallOperationsMetadataUpdateV1(ctx context.Context) ApiCallControllerCallOperationsMetadataUpdateV1Request {
	return ApiCallControllerCallOperationsMetadataUpdateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperationEntity
func (a *CallAPIService) CallControllerCallOperationsMetadataUpdateV1Execute(r ApiCallControllerCallOperationsMetadataUpdateV1Request) (*OperationEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperationEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsMetadataUpdateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.metadata.update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateResourceMetadataDto == nil {
		return localVarReturnValue, nil, reportError("updateResourceMetadataDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateResourceMetadataDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunCompositeV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	compositeV1Request *CompositeV1Request
}

func (r ApiCallControllerCallOperationsRunCompositeV1V1Request) CompositeV1Request(compositeV1Request CompositeV1Request) ApiCallControllerCallOperationsRunCompositeV1V1Request {
	r.compositeV1Request = &compositeV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunCompositeV1V1Request) Execute() (*CompositeV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunCompositeV1V1Execute(r)
}

/*
CallControllerCallOperationsRunCompositeV1V1 Method for CallControllerCallOperationsRunCompositeV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunCompositeV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunCompositeV1V1(ctx context.Context) ApiCallControllerCallOperationsRunCompositeV1V1Request {
	return ApiCallControllerCallOperationsRunCompositeV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompositeV1Response
func (a *CallAPIService) CallControllerCallOperationsRunCompositeV1V1Execute(r ApiCallControllerCallOperationsRunCompositeV1V1Request) (*CompositeV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompositeV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunCompositeV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.composite.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.compositeV1Request == nil {
		return localVarReturnValue, nil, reportError("compositeV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.compositeV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunCropV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	cropV1Request *CropV1Request
}

func (r ApiCallControllerCallOperationsRunCropV1V1Request) CropV1Request(cropV1Request CropV1Request) ApiCallControllerCallOperationsRunCropV1V1Request {
	r.cropV1Request = &cropV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunCropV1V1Request) Execute() (*CropV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunCropV1V1Execute(r)
}

/*
CallControllerCallOperationsRunCropV1V1 Method for CallControllerCallOperationsRunCropV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunCropV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunCropV1V1(ctx context.Context) ApiCallControllerCallOperationsRunCropV1V1Request {
	return ApiCallControllerCallOperationsRunCropV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CropV1Response
func (a *CallAPIService) CallControllerCallOperationsRunCropV1V1Execute(r ApiCallControllerCallOperationsRunCropV1V1Request) (*CropV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CropV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunCropV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.crop.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cropV1Request == nil {
		return localVarReturnValue, nil, reportError("cropV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cropV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunCutV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	cutV1Request *CutV1Request
}

func (r ApiCallControllerCallOperationsRunCutV1V1Request) CutV1Request(cutV1Request CutV1Request) ApiCallControllerCallOperationsRunCutV1V1Request {
	r.cutV1Request = &cutV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunCutV1V1Request) Execute() (*CutV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunCutV1V1Execute(r)
}

/*
CallControllerCallOperationsRunCutV1V1 Method for CallControllerCallOperationsRunCutV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunCutV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunCutV1V1(ctx context.Context) ApiCallControllerCallOperationsRunCutV1V1Request {
	return ApiCallControllerCallOperationsRunCutV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CutV1Response
func (a *CallAPIService) CallControllerCallOperationsRunCutV1V1Execute(r ApiCallControllerCallOperationsRunCutV1V1Request) (*CutV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CutV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunCutV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.cut.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cutV1Request == nil {
		return localVarReturnValue, nil, reportError("cutV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cutV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunGptV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	gptV1Request *GptV1Request
}

func (r ApiCallControllerCallOperationsRunGptV1V1Request) GptV1Request(gptV1Request GptV1Request) ApiCallControllerCallOperationsRunGptV1V1Request {
	r.gptV1Request = &gptV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunGptV1V1Request) Execute() (*GptV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunGptV1V1Execute(r)
}

/*
CallControllerCallOperationsRunGptV1V1 Method for CallControllerCallOperationsRunGptV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunGptV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunGptV1V1(ctx context.Context) ApiCallControllerCallOperationsRunGptV1V1Request {
	return ApiCallControllerCallOperationsRunGptV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GptV1Response
func (a *CallAPIService) CallControllerCallOperationsRunGptV1V1Execute(r ApiCallControllerCallOperationsRunGptV1V1Request) (*GptV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GptV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunGptV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.gpt.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gptV1Request == nil {
		return localVarReturnValue, nil, reportError("gptV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gptV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunHauteLindaV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	hauteLindaV1Request *HauteLindaV1Request
}

func (r ApiCallControllerCallOperationsRunHauteLindaV1V1Request) HauteLindaV1Request(hauteLindaV1Request HauteLindaV1Request) ApiCallControllerCallOperationsRunHauteLindaV1V1Request {
	r.hauteLindaV1Request = &hauteLindaV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunHauteLindaV1V1Request) Execute() (*HauteLindaV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunHauteLindaV1V1Execute(r)
}

/*
CallControllerCallOperationsRunHauteLindaV1V1 Method for CallControllerCallOperationsRunHauteLindaV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunHauteLindaV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunHauteLindaV1V1(ctx context.Context) ApiCallControllerCallOperationsRunHauteLindaV1V1Request {
	return ApiCallControllerCallOperationsRunHauteLindaV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HauteLindaV1Response
func (a *CallAPIService) CallControllerCallOperationsRunHauteLindaV1V1Execute(r ApiCallControllerCallOperationsRunHauteLindaV1V1Request) (*HauteLindaV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HauteLindaV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunHauteLindaV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.haute.linda.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hauteLindaV1Request == nil {
		return localVarReturnValue, nil, reportError("hauteLindaV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hauteLindaV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunHauteNaomiV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	hauteNaomiV1Request *HauteNaomiV1Request
}

func (r ApiCallControllerCallOperationsRunHauteNaomiV1V1Request) HauteNaomiV1Request(hauteNaomiV1Request HauteNaomiV1Request) ApiCallControllerCallOperationsRunHauteNaomiV1V1Request {
	r.hauteNaomiV1Request = &hauteNaomiV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunHauteNaomiV1V1Request) Execute() (*HauteNaomiV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunHauteNaomiV1V1Execute(r)
}

/*
CallControllerCallOperationsRunHauteNaomiV1V1 Method for CallControllerCallOperationsRunHauteNaomiV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunHauteNaomiV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunHauteNaomiV1V1(ctx context.Context) ApiCallControllerCallOperationsRunHauteNaomiV1V1Request {
	return ApiCallControllerCallOperationsRunHauteNaomiV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HauteNaomiV1Response
func (a *CallAPIService) CallControllerCallOperationsRunHauteNaomiV1V1Execute(r ApiCallControllerCallOperationsRunHauteNaomiV1V1Request) (*HauteNaomiV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HauteNaomiV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunHauteNaomiV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.haute.naomi.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hauteNaomiV1Request == nil {
		return localVarReturnValue, nil, reportError("hauteNaomiV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hauteNaomiV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunImagineKateV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	imagineKateV1Request *ImagineKateV1Request
}

func (r ApiCallControllerCallOperationsRunImagineKateV1V1Request) ImagineKateV1Request(imagineKateV1Request ImagineKateV1Request) ApiCallControllerCallOperationsRunImagineKateV1V1Request {
	r.imagineKateV1Request = &imagineKateV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunImagineKateV1V1Request) Execute() (*ImagineKateV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunImagineKateV1V1Execute(r)
}

/*
CallControllerCallOperationsRunImagineKateV1V1 Method for CallControllerCallOperationsRunImagineKateV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunImagineKateV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunImagineKateV1V1(ctx context.Context) ApiCallControllerCallOperationsRunImagineKateV1V1Request {
	return ApiCallControllerCallOperationsRunImagineKateV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImagineKateV1Response
func (a *CallAPIService) CallControllerCallOperationsRunImagineKateV1V1Execute(r ApiCallControllerCallOperationsRunImagineKateV1V1Request) (*ImagineKateV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImagineKateV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunImagineKateV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.imagine.kate.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.imagineKateV1Request == nil {
		return localVarReturnValue, nil, reportError("imagineKateV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.imagineKateV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunInpaintKateV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	inpaintKateV1Request *InpaintKateV1Request
}

func (r ApiCallControllerCallOperationsRunInpaintKateV1V1Request) InpaintKateV1Request(inpaintKateV1Request InpaintKateV1Request) ApiCallControllerCallOperationsRunInpaintKateV1V1Request {
	r.inpaintKateV1Request = &inpaintKateV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunInpaintKateV1V1Request) Execute() (*InpaintKateV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunInpaintKateV1V1Execute(r)
}

/*
CallControllerCallOperationsRunInpaintKateV1V1 Method for CallControllerCallOperationsRunInpaintKateV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunInpaintKateV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunInpaintKateV1V1(ctx context.Context) ApiCallControllerCallOperationsRunInpaintKateV1V1Request {
	return ApiCallControllerCallOperationsRunInpaintKateV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InpaintKateV1Response
func (a *CallAPIService) CallControllerCallOperationsRunInpaintKateV1V1Execute(r ApiCallControllerCallOperationsRunInpaintKateV1V1Request) (*InpaintKateV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InpaintKateV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunInpaintKateV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.inpaint.kate.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inpaintKateV1Request == nil {
		return localVarReturnValue, nil, reportError("inpaintKateV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inpaintKateV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunNegateImageV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	negateImageV1Request *NegateImageV1Request
}

func (r ApiCallControllerCallOperationsRunNegateImageV1V1Request) NegateImageV1Request(negateImageV1Request NegateImageV1Request) ApiCallControllerCallOperationsRunNegateImageV1V1Request {
	r.negateImageV1Request = &negateImageV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunNegateImageV1V1Request) Execute() (*NegateImageV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunNegateImageV1V1Execute(r)
}

/*
CallControllerCallOperationsRunNegateImageV1V1 Method for CallControllerCallOperationsRunNegateImageV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunNegateImageV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunNegateImageV1V1(ctx context.Context) ApiCallControllerCallOperationsRunNegateImageV1V1Request {
	return ApiCallControllerCallOperationsRunNegateImageV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NegateImageV1Response
func (a *CallAPIService) CallControllerCallOperationsRunNegateImageV1V1Execute(r ApiCallControllerCallOperationsRunNegateImageV1V1Request) (*NegateImageV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegateImageV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunNegateImageV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.negateImage.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.negateImageV1Request == nil {
		return localVarReturnValue, nil, reportError("negateImageV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.negateImageV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunNoiseV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	noiseV1Request *NoiseV1Request
}

func (r ApiCallControllerCallOperationsRunNoiseV1V1Request) NoiseV1Request(noiseV1Request NoiseV1Request) ApiCallControllerCallOperationsRunNoiseV1V1Request {
	r.noiseV1Request = &noiseV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunNoiseV1V1Request) Execute() (*NoiseV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunNoiseV1V1Execute(r)
}

/*
CallControllerCallOperationsRunNoiseV1V1 Method for CallControllerCallOperationsRunNoiseV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunNoiseV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunNoiseV1V1(ctx context.Context) ApiCallControllerCallOperationsRunNoiseV1V1Request {
	return ApiCallControllerCallOperationsRunNoiseV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NoiseV1Response
func (a *CallAPIService) CallControllerCallOperationsRunNoiseV1V1Execute(r ApiCallControllerCallOperationsRunNoiseV1V1Request) (*NoiseV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NoiseV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunNoiseV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.noise.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.noiseV1Request == nil {
		return localVarReturnValue, nil, reportError("noiseV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.noiseV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunObjectDetectionV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	objectDetectionV1Request *ObjectDetectionV1Request
}

func (r ApiCallControllerCallOperationsRunObjectDetectionV1V1Request) ObjectDetectionV1Request(objectDetectionV1Request ObjectDetectionV1Request) ApiCallControllerCallOperationsRunObjectDetectionV1V1Request {
	r.objectDetectionV1Request = &objectDetectionV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunObjectDetectionV1V1Request) Execute() (*ObjectDetectionV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunObjectDetectionV1V1Execute(r)
}

/*
CallControllerCallOperationsRunObjectDetectionV1V1 Method for CallControllerCallOperationsRunObjectDetectionV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunObjectDetectionV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunObjectDetectionV1V1(ctx context.Context) ApiCallControllerCallOperationsRunObjectDetectionV1V1Request {
	return ApiCallControllerCallOperationsRunObjectDetectionV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectDetectionV1Response
func (a *CallAPIService) CallControllerCallOperationsRunObjectDetectionV1V1Execute(r ApiCallControllerCallOperationsRunObjectDetectionV1V1Request) (*ObjectDetectionV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectDetectionV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunObjectDetectionV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.objectDetection.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.objectDetectionV1Request == nil {
		return localVarReturnValue, nil, reportError("objectDetectionV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.objectDetectionV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunPoseEstimationV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	poseEstimationV1Request *PoseEstimationV1Request
}

func (r ApiCallControllerCallOperationsRunPoseEstimationV1V1Request) PoseEstimationV1Request(poseEstimationV1Request PoseEstimationV1Request) ApiCallControllerCallOperationsRunPoseEstimationV1V1Request {
	r.poseEstimationV1Request = &poseEstimationV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunPoseEstimationV1V1Request) Execute() (*PoseEstimationV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunPoseEstimationV1V1Execute(r)
}

/*
CallControllerCallOperationsRunPoseEstimationV1V1 Method for CallControllerCallOperationsRunPoseEstimationV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunPoseEstimationV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunPoseEstimationV1V1(ctx context.Context) ApiCallControllerCallOperationsRunPoseEstimationV1V1Request {
	return ApiCallControllerCallOperationsRunPoseEstimationV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PoseEstimationV1Response
func (a *CallAPIService) CallControllerCallOperationsRunPoseEstimationV1V1Execute(r ApiCallControllerCallOperationsRunPoseEstimationV1V1Request) (*PoseEstimationV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PoseEstimationV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunPoseEstimationV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.poseEstimation.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.poseEstimationV1Request == nil {
		return localVarReturnValue, nil, reportError("poseEstimationV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poseEstimationV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	segmentAnythingEmbeddingsV1Request *SegmentAnythingEmbeddingsV1Request
}

func (r ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request) SegmentAnythingEmbeddingsV1Request(segmentAnythingEmbeddingsV1Request SegmentAnythingEmbeddingsV1Request) ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request {
	r.segmentAnythingEmbeddingsV1Request = &segmentAnythingEmbeddingsV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request) Execute() (*SegmentAnythingEmbeddingsV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Execute(r)
}

/*
CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1 Method for CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1(ctx context.Context) ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request {
	return ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SegmentAnythingEmbeddingsV1Response
func (a *CallAPIService) CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Execute(r ApiCallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1Request) (*SegmentAnythingEmbeddingsV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SegmentAnythingEmbeddingsV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunSegmentAnythingEmbeddingsV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.segmentAnything.embeddings.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.segmentAnythingEmbeddingsV1Request == nil {
		return localVarReturnValue, nil, reportError("segmentAnythingEmbeddingsV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.segmentAnythingEmbeddingsV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	segmentAnythingMaskV1Request *SegmentAnythingMaskV1Request
}

func (r ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request) SegmentAnythingMaskV1Request(segmentAnythingMaskV1Request SegmentAnythingMaskV1Request) ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request {
	r.segmentAnythingMaskV1Request = &segmentAnythingMaskV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request) Execute() (*SegmentAnythingMaskV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunSegmentAnythingMaskV1V1Execute(r)
}

/*
CallControllerCallOperationsRunSegmentAnythingMaskV1V1 Method for CallControllerCallOperationsRunSegmentAnythingMaskV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunSegmentAnythingMaskV1V1(ctx context.Context) ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request {
	return ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SegmentAnythingMaskV1Response
func (a *CallAPIService) CallControllerCallOperationsRunSegmentAnythingMaskV1V1Execute(r ApiCallControllerCallOperationsRunSegmentAnythingMaskV1V1Request) (*SegmentAnythingMaskV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SegmentAnythingMaskV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunSegmentAnythingMaskV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.segmentAnything.mask.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.segmentAnythingMaskV1Request == nil {
		return localVarReturnValue, nil, reportError("segmentAnythingMaskV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.segmentAnythingMaskV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunUpscaleV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	upscaleV1Request *UpscaleV1Request
}

func (r ApiCallControllerCallOperationsRunUpscaleV1V1Request) UpscaleV1Request(upscaleV1Request UpscaleV1Request) ApiCallControllerCallOperationsRunUpscaleV1V1Request {
	r.upscaleV1Request = &upscaleV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunUpscaleV1V1Request) Execute() (*UpscaleV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunUpscaleV1V1Execute(r)
}

/*
CallControllerCallOperationsRunUpscaleV1V1 Method for CallControllerCallOperationsRunUpscaleV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunUpscaleV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunUpscaleV1V1(ctx context.Context) ApiCallControllerCallOperationsRunUpscaleV1V1Request {
	return ApiCallControllerCallOperationsRunUpscaleV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpscaleV1Response
func (a *CallAPIService) CallControllerCallOperationsRunUpscaleV1V1Execute(r ApiCallControllerCallOperationsRunUpscaleV1V1Request) (*UpscaleV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpscaleV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunUpscaleV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.upscale.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.upscaleV1Request == nil {
		return localVarReturnValue, nil, reportError("upscaleV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upscaleV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsRunVtonGiseleV1V1Request struct {
	ctx context.Context
	ApiService CallAPI
	vtonGiseleV1Request *VtonGiseleV1Request
}

func (r ApiCallControllerCallOperationsRunVtonGiseleV1V1Request) VtonGiseleV1Request(vtonGiseleV1Request VtonGiseleV1Request) ApiCallControllerCallOperationsRunVtonGiseleV1V1Request {
	r.vtonGiseleV1Request = &vtonGiseleV1Request
	return r
}

func (r ApiCallControllerCallOperationsRunVtonGiseleV1V1Request) Execute() (*VtonGiseleV1Response, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsRunVtonGiseleV1V1Execute(r)
}

/*
CallControllerCallOperationsRunVtonGiseleV1V1 Method for CallControllerCallOperationsRunVtonGiseleV1V1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsRunVtonGiseleV1V1Request
*/
func (a *CallAPIService) CallControllerCallOperationsRunVtonGiseleV1V1(ctx context.Context) ApiCallControllerCallOperationsRunVtonGiseleV1V1Request {
	return ApiCallControllerCallOperationsRunVtonGiseleV1V1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VtonGiseleV1Response
func (a *CallAPIService) CallControllerCallOperationsRunVtonGiseleV1V1Execute(r ApiCallControllerCallOperationsRunVtonGiseleV1V1Request) (*VtonGiseleV1Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VtonGiseleV1Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsRunVtonGiseleV1V1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.run.vton.gisele.v1"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vtonGiseleV1Request == nil {
		return localVarReturnValue, nil, reportError("vtonGiseleV1Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vtonGiseleV1Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallOperationsWaitV1Request struct {
	ctx context.Context
	ApiService CallAPI
	waitOperationParamsDto *WaitOperationParamsDto
}

func (r ApiCallControllerCallOperationsWaitV1Request) WaitOperationParamsDto(waitOperationParamsDto WaitOperationParamsDto) ApiCallControllerCallOperationsWaitV1Request {
	r.waitOperationParamsDto = &waitOperationParamsDto
	return r
}

func (r ApiCallControllerCallOperationsWaitV1Request) Execute() (*OperationEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallOperationsWaitV1Execute(r)
}

/*
CallControllerCallOperationsWaitV1 Method for CallControllerCallOperationsWaitV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallOperationsWaitV1Request
*/
func (a *CallAPIService) CallControllerCallOperationsWaitV1(ctx context.Context) ApiCallControllerCallOperationsWaitV1Request {
	return ApiCallControllerCallOperationsWaitV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OperationEntity
func (a *CallAPIService) CallControllerCallOperationsWaitV1Execute(r ApiCallControllerCallOperationsWaitV1Request) (*OperationEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OperationEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallOperationsWaitV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/operations.wait"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.waitOperationParamsDto == nil {
		return localVarReturnValue, nil, reportError("waitOperationParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.waitOperationParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallPosesGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getPoseParamsDto *GetPoseParamsDto
}

func (r ApiCallControllerCallPosesGetV1Request) GetPoseParamsDto(getPoseParamsDto GetPoseParamsDto) ApiCallControllerCallPosesGetV1Request {
	r.getPoseParamsDto = &getPoseParamsDto
	return r
}

func (r ApiCallControllerCallPosesGetV1Request) Execute() (*PoseEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallPosesGetV1Execute(r)
}

/*
CallControllerCallPosesGetV1 Method for CallControllerCallPosesGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallPosesGetV1Request
*/
func (a *CallAPIService) CallControllerCallPosesGetV1(ctx context.Context) ApiCallControllerCallPosesGetV1Request {
	return ApiCallControllerCallPosesGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PoseEntity
func (a *CallAPIService) CallControllerCallPosesGetV1Execute(r ApiCallControllerCallPosesGetV1Request) (*PoseEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PoseEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallPosesGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/poses.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getPoseParamsDto == nil {
		return localVarReturnValue, nil, reportError("getPoseParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getPoseParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallPosesListV1Request struct {
	ctx context.Context
	ApiService CallAPI
	listPosesParamsDto *ListPosesParamsDto
}

func (r ApiCallControllerCallPosesListV1Request) ListPosesParamsDto(listPosesParamsDto ListPosesParamsDto) ApiCallControllerCallPosesListV1Request {
	r.listPosesParamsDto = &listPosesParamsDto
	return r
}

func (r ApiCallControllerCallPosesListV1Request) Execute() (*ListPosesDto, *http.Response, error) {
	return r.ApiService.CallControllerCallPosesListV1Execute(r)
}

/*
CallControllerCallPosesListV1 Method for CallControllerCallPosesListV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallPosesListV1Request
*/
func (a *CallAPIService) CallControllerCallPosesListV1(ctx context.Context) ApiCallControllerCallPosesListV1Request {
	return ApiCallControllerCallPosesListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPosesDto
func (a *CallAPIService) CallControllerCallPosesListV1Execute(r ApiCallControllerCallPosesListV1Request) (*ListPosesDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPosesDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallPosesListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/poses.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listPosesParamsDto == nil {
		return localVarReturnValue, nil, reportError("listPosesParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listPosesParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallPosesPreviewSetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	setPosePreviewDto *SetPosePreviewDto
}

func (r ApiCallControllerCallPosesPreviewSetV1Request) SetPosePreviewDto(setPosePreviewDto SetPosePreviewDto) ApiCallControllerCallPosesPreviewSetV1Request {
	r.setPosePreviewDto = &setPosePreviewDto
	return r
}

func (r ApiCallControllerCallPosesPreviewSetV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallPosesPreviewSetV1Execute(r)
}

/*
CallControllerCallPosesPreviewSetV1 Method for CallControllerCallPosesPreviewSetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallPosesPreviewSetV1Request
*/
func (a *CallAPIService) CallControllerCallPosesPreviewSetV1(ctx context.Context) ApiCallControllerCallPosesPreviewSetV1Request {
	return ApiCallControllerCallPosesPreviewSetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallPosesPreviewSetV1Execute(r ApiCallControllerCallPosesPreviewSetV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallPosesPreviewSetV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/poses.preview.set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setPosePreviewDto == nil {
		return nil, reportError("setPosePreviewDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setPosePreviewDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallStacksCreateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	createStackParamsDto *CreateStackParamsDto
}

func (r ApiCallControllerCallStacksCreateV1Request) CreateStackParamsDto(createStackParamsDto CreateStackParamsDto) ApiCallControllerCallStacksCreateV1Request {
	r.createStackParamsDto = &createStackParamsDto
	return r
}

func (r ApiCallControllerCallStacksCreateV1Request) Execute() (*StackEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallStacksCreateV1Execute(r)
}

/*
CallControllerCallStacksCreateV1 Method for CallControllerCallStacksCreateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStacksCreateV1Request
*/
func (a *CallAPIService) CallControllerCallStacksCreateV1(ctx context.Context) ApiCallControllerCallStacksCreateV1Request {
	return ApiCallControllerCallStacksCreateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StackEntity
func (a *CallAPIService) CallControllerCallStacksCreateV1Execute(r ApiCallControllerCallStacksCreateV1Request) (*StackEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StackEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStacksCreateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/stacks.create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createStackParamsDto == nil {
		return localVarReturnValue, nil, reportError("createStackParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createStackParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallStacksGetV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getStackParamsDto *GetStackParamsDto
}

func (r ApiCallControllerCallStacksGetV1Request) GetStackParamsDto(getStackParamsDto GetStackParamsDto) ApiCallControllerCallStacksGetV1Request {
	r.getStackParamsDto = &getStackParamsDto
	return r
}

func (r ApiCallControllerCallStacksGetV1Request) Execute() (*StackEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallStacksGetV1Execute(r)
}

/*
CallControllerCallStacksGetV1 Method for CallControllerCallStacksGetV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStacksGetV1Request
*/
func (a *CallAPIService) CallControllerCallStacksGetV1(ctx context.Context) ApiCallControllerCallStacksGetV1Request {
	return ApiCallControllerCallStacksGetV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StackEntity
func (a *CallAPIService) CallControllerCallStacksGetV1Execute(r ApiCallControllerCallStacksGetV1Request) (*StackEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StackEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStacksGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/stacks.get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getStackParamsDto == nil {
		return localVarReturnValue, nil, reportError("getStackParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getStackParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallStacksItemsAddV1Request struct {
	ctx context.Context
	ApiService CallAPI
	addItemsToStackParamsDto *AddItemsToStackParamsDto
}

func (r ApiCallControllerCallStacksItemsAddV1Request) AddItemsToStackParamsDto(addItemsToStackParamsDto AddItemsToStackParamsDto) ApiCallControllerCallStacksItemsAddV1Request {
	r.addItemsToStackParamsDto = &addItemsToStackParamsDto
	return r
}

func (r ApiCallControllerCallStacksItemsAddV1Request) Execute() (*StackEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallStacksItemsAddV1Execute(r)
}

/*
CallControllerCallStacksItemsAddV1 Method for CallControllerCallStacksItemsAddV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStacksItemsAddV1Request
*/
func (a *CallAPIService) CallControllerCallStacksItemsAddV1(ctx context.Context) ApiCallControllerCallStacksItemsAddV1Request {
	return ApiCallControllerCallStacksItemsAddV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StackEntity
func (a *CallAPIService) CallControllerCallStacksItemsAddV1Execute(r ApiCallControllerCallStacksItemsAddV1Request) (*StackEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StackEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStacksItemsAddV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/stacks.items.add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addItemsToStackParamsDto == nil {
		return localVarReturnValue, nil, reportError("addItemsToStackParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addItemsToStackParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallStacksItemsRemoveV1Request struct {
	ctx context.Context
	ApiService CallAPI
	removeItemsFromStackParamsDto *RemoveItemsFromStackParamsDto
}

func (r ApiCallControllerCallStacksItemsRemoveV1Request) RemoveItemsFromStackParamsDto(removeItemsFromStackParamsDto RemoveItemsFromStackParamsDto) ApiCallControllerCallStacksItemsRemoveV1Request {
	r.removeItemsFromStackParamsDto = &removeItemsFromStackParamsDto
	return r
}

func (r ApiCallControllerCallStacksItemsRemoveV1Request) Execute() (*StackEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallStacksItemsRemoveV1Execute(r)
}

/*
CallControllerCallStacksItemsRemoveV1 Method for CallControllerCallStacksItemsRemoveV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStacksItemsRemoveV1Request
*/
func (a *CallAPIService) CallControllerCallStacksItemsRemoveV1(ctx context.Context) ApiCallControllerCallStacksItemsRemoveV1Request {
	return ApiCallControllerCallStacksItemsRemoveV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StackEntity
func (a *CallAPIService) CallControllerCallStacksItemsRemoveV1Execute(r ApiCallControllerCallStacksItemsRemoveV1Request) (*StackEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StackEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStacksItemsRemoveV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/stacks.items.remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeItemsFromStackParamsDto == nil {
		return localVarReturnValue, nil, reportError("removeItemsFromStackParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeItemsFromStackParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallStacksListV1Request struct {
	ctx context.Context
	ApiService CallAPI
	listStacksParamsDto *ListStacksParamsDto
}

func (r ApiCallControllerCallStacksListV1Request) ListStacksParamsDto(listStacksParamsDto ListStacksParamsDto) ApiCallControllerCallStacksListV1Request {
	r.listStacksParamsDto = &listStacksParamsDto
	return r
}

func (r ApiCallControllerCallStacksListV1Request) Execute() (*ListStacksDto, *http.Response, error) {
	return r.ApiService.CallControllerCallStacksListV1Execute(r)
}

/*
CallControllerCallStacksListV1 Method for CallControllerCallStacksListV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStacksListV1Request
*/
func (a *CallAPIService) CallControllerCallStacksListV1(ctx context.Context) ApiCallControllerCallStacksListV1Request {
	return ApiCallControllerCallStacksListV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListStacksDto
func (a *CallAPIService) CallControllerCallStacksListV1Execute(r ApiCallControllerCallStacksListV1Request) (*ListStacksDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListStacksDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStacksListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/stacks.list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listStacksParamsDto == nil {
		return localVarReturnValue, nil, reportError("listStacksParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listStacksParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallStacksMetadataUpdateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	updateResourceMetadataDto *UpdateResourceMetadataDto
}

func (r ApiCallControllerCallStacksMetadataUpdateV1Request) UpdateResourceMetadataDto(updateResourceMetadataDto UpdateResourceMetadataDto) ApiCallControllerCallStacksMetadataUpdateV1Request {
	r.updateResourceMetadataDto = &updateResourceMetadataDto
	return r
}

func (r ApiCallControllerCallStacksMetadataUpdateV1Request) Execute() (*StackEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallStacksMetadataUpdateV1Execute(r)
}

/*
CallControllerCallStacksMetadataUpdateV1 Method for CallControllerCallStacksMetadataUpdateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStacksMetadataUpdateV1Request
*/
func (a *CallAPIService) CallControllerCallStacksMetadataUpdateV1(ctx context.Context) ApiCallControllerCallStacksMetadataUpdateV1Request {
	return ApiCallControllerCallStacksMetadataUpdateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StackEntity
func (a *CallAPIService) CallControllerCallStacksMetadataUpdateV1Execute(r ApiCallControllerCallStacksMetadataUpdateV1Request) (*StackEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StackEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStacksMetadataUpdateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/stacks.metadata.update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateResourceMetadataDto == nil {
		return localVarReturnValue, nil, reportError("updateResourceMetadataDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateResourceMetadataDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallStorageCreateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	createStorageRecordParamsDto *CreateStorageRecordParamsDto
}

func (r ApiCallControllerCallStorageCreateV1Request) CreateStorageRecordParamsDto(createStorageRecordParamsDto CreateStorageRecordParamsDto) ApiCallControllerCallStorageCreateV1Request {
	r.createStorageRecordParamsDto = &createStorageRecordParamsDto
	return r
}

func (r ApiCallControllerCallStorageCreateV1Request) Execute() (*StorageEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallStorageCreateV1Execute(r)
}

/*
CallControllerCallStorageCreateV1 Method for CallControllerCallStorageCreateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStorageCreateV1Request
*/
func (a *CallAPIService) CallControllerCallStorageCreateV1(ctx context.Context) ApiCallControllerCallStorageCreateV1Request {
	return ApiCallControllerCallStorageCreateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StorageEntity
func (a *CallAPIService) CallControllerCallStorageCreateV1Execute(r ApiCallControllerCallStorageCreateV1Request) (*StorageEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StorageEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStorageCreateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/storage.create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createStorageRecordParamsDto == nil {
		return localVarReturnValue, nil, reportError("createStorageRecordParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createStorageRecordParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallStorageDeleteV1Request struct {
	ctx context.Context
	ApiService CallAPI
	deleteStorageParamsDto *DeleteStorageParamsDto
}

func (r ApiCallControllerCallStorageDeleteV1Request) DeleteStorageParamsDto(deleteStorageParamsDto DeleteStorageParamsDto) ApiCallControllerCallStorageDeleteV1Request {
	r.deleteStorageParamsDto = &deleteStorageParamsDto
	return r
}

func (r ApiCallControllerCallStorageDeleteV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CallControllerCallStorageDeleteV1Execute(r)
}

/*
CallControllerCallStorageDeleteV1 Method for CallControllerCallStorageDeleteV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStorageDeleteV1Request
*/
func (a *CallAPIService) CallControllerCallStorageDeleteV1(ctx context.Context) ApiCallControllerCallStorageDeleteV1Request {
	return ApiCallControllerCallStorageDeleteV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CallAPIService) CallControllerCallStorageDeleteV1Execute(r ApiCallControllerCallStorageDeleteV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStorageDeleteV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/storage.delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteStorageParamsDto == nil {
		return nil, reportError("deleteStorageParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteStorageParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCallControllerCallStorageGetManyV1Request struct {
	ctx context.Context
	ApiService CallAPI
	getStorageRecordParamsDto *GetStorageRecordParamsDto
}

func (r ApiCallControllerCallStorageGetManyV1Request) GetStorageRecordParamsDto(getStorageRecordParamsDto GetStorageRecordParamsDto) ApiCallControllerCallStorageGetManyV1Request {
	r.getStorageRecordParamsDto = &getStorageRecordParamsDto
	return r
}

func (r ApiCallControllerCallStorageGetManyV1Request) Execute() ([]StorageRecordsResultDto, *http.Response, error) {
	return r.ApiService.CallControllerCallStorageGetManyV1Execute(r)
}

/*
CallControllerCallStorageGetManyV1 Method for CallControllerCallStorageGetManyV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStorageGetManyV1Request
*/
func (a *CallAPIService) CallControllerCallStorageGetManyV1(ctx context.Context) ApiCallControllerCallStorageGetManyV1Request {
	return ApiCallControllerCallStorageGetManyV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []StorageRecordsResultDto
func (a *CallAPIService) CallControllerCallStorageGetManyV1Execute(r ApiCallControllerCallStorageGetManyV1Request) ([]StorageRecordsResultDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StorageRecordsResultDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStorageGetManyV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/storage.getMany"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getStorageRecordParamsDto == nil {
		return localVarReturnValue, nil, reportError("getStorageRecordParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getStorageRecordParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCallControllerCallStorageUpdateV1Request struct {
	ctx context.Context
	ApiService CallAPI
	updateStorageRecordParamsDto *UpdateStorageRecordParamsDto
}

func (r ApiCallControllerCallStorageUpdateV1Request) UpdateStorageRecordParamsDto(updateStorageRecordParamsDto UpdateStorageRecordParamsDto) ApiCallControllerCallStorageUpdateV1Request {
	r.updateStorageRecordParamsDto = &updateStorageRecordParamsDto
	return r
}

func (r ApiCallControllerCallStorageUpdateV1Request) Execute() (*StorageEntity, *http.Response, error) {
	return r.ApiService.CallControllerCallStorageUpdateV1Execute(r)
}

/*
CallControllerCallStorageUpdateV1 Method for CallControllerCallStorageUpdateV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCallControllerCallStorageUpdateV1Request
*/
func (a *CallAPIService) CallControllerCallStorageUpdateV1(ctx context.Context) ApiCallControllerCallStorageUpdateV1Request {
	return ApiCallControllerCallStorageUpdateV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StorageEntity
func (a *CallAPIService) CallControllerCallStorageUpdateV1Execute(r ApiCallControllerCallStorageUpdateV1Request) (*StorageEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StorageEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallAPIService.CallControllerCallStorageUpdateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/call/storage.update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateStorageRecordParamsDto == nil {
		return localVarReturnValue, nil, reportError("updateStorageRecordParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStorageRecordParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
