/*
Hautech API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hautechapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type CollectionsAPI interface {

	/*
	CollectionsControllerAddItemsV1 Method for CollectionsControllerAddItemsV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCollectionsControllerAddItemsV1Request
	*/
	CollectionsControllerAddItemsV1(ctx context.Context, id string) ApiCollectionsControllerAddItemsV1Request

	// CollectionsControllerAddItemsV1Execute executes the request
	CollectionsControllerAddItemsV1Execute(r ApiCollectionsControllerAddItemsV1Request) (*http.Response, error)

	/*
	CollectionsControllerCreateCollectionV1 Method for CollectionsControllerCreateCollectionV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCollectionsControllerCreateCollectionV1Request
	*/
	CollectionsControllerCreateCollectionV1(ctx context.Context) ApiCollectionsControllerCreateCollectionV1Request

	// CollectionsControllerCreateCollectionV1Execute executes the request
	//  @return CollectionEntity
	CollectionsControllerCreateCollectionV1Execute(r ApiCollectionsControllerCreateCollectionV1Request) (*CollectionEntity, *http.Response, error)

	/*
	CollectionsControllerGetCollectionV1 Method for CollectionsControllerGetCollectionV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCollectionsControllerGetCollectionV1Request
	*/
	CollectionsControllerGetCollectionV1(ctx context.Context, id string) ApiCollectionsControllerGetCollectionV1Request

	// CollectionsControllerGetCollectionV1Execute executes the request
	//  @return CollectionEntity
	CollectionsControllerGetCollectionV1Execute(r ApiCollectionsControllerGetCollectionV1Request) (*CollectionEntity, *http.Response, error)

	/*
	CollectionsControllerListCollectionsV1 Method for CollectionsControllerListCollectionsV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCollectionsControllerListCollectionsV1Request
	*/
	CollectionsControllerListCollectionsV1(ctx context.Context) ApiCollectionsControllerListCollectionsV1Request

	// CollectionsControllerListCollectionsV1Execute executes the request
	//  @return ListCollectionsDto
	CollectionsControllerListCollectionsV1Execute(r ApiCollectionsControllerListCollectionsV1Request) (*ListCollectionsDto, *http.Response, error)

	/*
	CollectionsControllerListItemsV1 Method for CollectionsControllerListItemsV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCollectionsControllerListItemsV1Request
	*/
	CollectionsControllerListItemsV1(ctx context.Context, id string) ApiCollectionsControllerListItemsV1Request

	// CollectionsControllerListItemsV1Execute executes the request
	//  @return ListCollectionItemsDto
	CollectionsControllerListItemsV1Execute(r ApiCollectionsControllerListItemsV1Request) (*ListCollectionItemsDto, *http.Response, error)

	/*
	CollectionsControllerRemoveItemsV1 Method for CollectionsControllerRemoveItemsV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCollectionsControllerRemoveItemsV1Request
	*/
	CollectionsControllerRemoveItemsV1(ctx context.Context, id string) ApiCollectionsControllerRemoveItemsV1Request

	// CollectionsControllerRemoveItemsV1Execute executes the request
	CollectionsControllerRemoveItemsV1Execute(r ApiCollectionsControllerRemoveItemsV1Request) (*http.Response, error)

	/*
	CollectionsControllerUpdateMetadataV1 Method for CollectionsControllerUpdateMetadataV1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return ApiCollectionsControllerUpdateMetadataV1Request
	*/
	CollectionsControllerUpdateMetadataV1(ctx context.Context, id string) ApiCollectionsControllerUpdateMetadataV1Request

	// CollectionsControllerUpdateMetadataV1Execute executes the request
	//  @return ResourceEntity
	CollectionsControllerUpdateMetadataV1Execute(r ApiCollectionsControllerUpdateMetadataV1Request) (*ResourceEntity, *http.Response, error)
}

// CollectionsAPIService CollectionsAPI service
type CollectionsAPIService service

type ApiCollectionsControllerAddItemsV1Request struct {
	ctx context.Context
	ApiService CollectionsAPI
	id string
	addItemsToCollectionControllerParamsDto *AddItemsToCollectionControllerParamsDto
}

func (r ApiCollectionsControllerAddItemsV1Request) AddItemsToCollectionControllerParamsDto(addItemsToCollectionControllerParamsDto AddItemsToCollectionControllerParamsDto) ApiCollectionsControllerAddItemsV1Request {
	r.addItemsToCollectionControllerParamsDto = &addItemsToCollectionControllerParamsDto
	return r
}

func (r ApiCollectionsControllerAddItemsV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CollectionsControllerAddItemsV1Execute(r)
}

/*
CollectionsControllerAddItemsV1 Method for CollectionsControllerAddItemsV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCollectionsControllerAddItemsV1Request
*/
func (a *CollectionsAPIService) CollectionsControllerAddItemsV1(ctx context.Context, id string) ApiCollectionsControllerAddItemsV1Request {
	return ApiCollectionsControllerAddItemsV1Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CollectionsAPIService) CollectionsControllerAddItemsV1Execute(r ApiCollectionsControllerAddItemsV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.CollectionsControllerAddItemsV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{id}/items/add"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addItemsToCollectionControllerParamsDto == nil {
		return nil, reportError("addItemsToCollectionControllerParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addItemsToCollectionControllerParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCollectionsControllerCreateCollectionV1Request struct {
	ctx context.Context
	ApiService CollectionsAPI
	createCollectionParamsDto *CreateCollectionParamsDto
}

func (r ApiCollectionsControllerCreateCollectionV1Request) CreateCollectionParamsDto(createCollectionParamsDto CreateCollectionParamsDto) ApiCollectionsControllerCreateCollectionV1Request {
	r.createCollectionParamsDto = &createCollectionParamsDto
	return r
}

func (r ApiCollectionsControllerCreateCollectionV1Request) Execute() (*CollectionEntity, *http.Response, error) {
	return r.ApiService.CollectionsControllerCreateCollectionV1Execute(r)
}

/*
CollectionsControllerCreateCollectionV1 Method for CollectionsControllerCreateCollectionV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCollectionsControllerCreateCollectionV1Request
*/
func (a *CollectionsAPIService) CollectionsControllerCreateCollectionV1(ctx context.Context) ApiCollectionsControllerCreateCollectionV1Request {
	return ApiCollectionsControllerCreateCollectionV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionEntity
func (a *CollectionsAPIService) CollectionsControllerCreateCollectionV1Execute(r ApiCollectionsControllerCreateCollectionV1Request) (*CollectionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.CollectionsControllerCreateCollectionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCollectionParamsDto == nil {
		return localVarReturnValue, nil, reportError("createCollectionParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCollectionParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCollectionsControllerGetCollectionV1Request struct {
	ctx context.Context
	ApiService CollectionsAPI
	id string
}

func (r ApiCollectionsControllerGetCollectionV1Request) Execute() (*CollectionEntity, *http.Response, error) {
	return r.ApiService.CollectionsControllerGetCollectionV1Execute(r)
}

/*
CollectionsControllerGetCollectionV1 Method for CollectionsControllerGetCollectionV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCollectionsControllerGetCollectionV1Request
*/
func (a *CollectionsAPIService) CollectionsControllerGetCollectionV1(ctx context.Context, id string) ApiCollectionsControllerGetCollectionV1Request {
	return ApiCollectionsControllerGetCollectionV1Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CollectionEntity
func (a *CollectionsAPIService) CollectionsControllerGetCollectionV1Execute(r ApiCollectionsControllerGetCollectionV1Request) (*CollectionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.CollectionsControllerGetCollectionV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCollectionsControllerListCollectionsV1Request struct {
	ctx context.Context
	ApiService CollectionsAPI
	orderBy *string
	limit *float32
	cursor *string
}

func (r ApiCollectionsControllerListCollectionsV1Request) OrderBy(orderBy string) ApiCollectionsControllerListCollectionsV1Request {
	r.orderBy = &orderBy
	return r
}

func (r ApiCollectionsControllerListCollectionsV1Request) Limit(limit float32) ApiCollectionsControllerListCollectionsV1Request {
	r.limit = &limit
	return r
}

func (r ApiCollectionsControllerListCollectionsV1Request) Cursor(cursor string) ApiCollectionsControllerListCollectionsV1Request {
	r.cursor = &cursor
	return r
}

func (r ApiCollectionsControllerListCollectionsV1Request) Execute() (*ListCollectionsDto, *http.Response, error) {
	return r.ApiService.CollectionsControllerListCollectionsV1Execute(r)
}

/*
CollectionsControllerListCollectionsV1 Method for CollectionsControllerListCollectionsV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCollectionsControllerListCollectionsV1Request
*/
func (a *CollectionsAPIService) CollectionsControllerListCollectionsV1(ctx context.Context) ApiCollectionsControllerListCollectionsV1Request {
	return ApiCollectionsControllerListCollectionsV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListCollectionsDto
func (a *CollectionsAPIService) CollectionsControllerListCollectionsV1Execute(r ApiCollectionsControllerListCollectionsV1Request) (*ListCollectionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCollectionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.CollectionsControllerListCollectionsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	} else {
		var defaultValue string = "createdAt_DESC"
		r.orderBy = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue float32 = 50
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCollectionsControllerListItemsV1Request struct {
	ctx context.Context
	ApiService CollectionsAPI
	id string
	cursor *string
	orderBy *string
	limit *float32
	kind *string
}

func (r ApiCollectionsControllerListItemsV1Request) Cursor(cursor string) ApiCollectionsControllerListItemsV1Request {
	r.cursor = &cursor
	return r
}

func (r ApiCollectionsControllerListItemsV1Request) OrderBy(orderBy string) ApiCollectionsControllerListItemsV1Request {
	r.orderBy = &orderBy
	return r
}

func (r ApiCollectionsControllerListItemsV1Request) Limit(limit float32) ApiCollectionsControllerListItemsV1Request {
	r.limit = &limit
	return r
}

func (r ApiCollectionsControllerListItemsV1Request) Kind(kind string) ApiCollectionsControllerListItemsV1Request {
	r.kind = &kind
	return r
}

func (r ApiCollectionsControllerListItemsV1Request) Execute() (*ListCollectionItemsDto, *http.Response, error) {
	return r.ApiService.CollectionsControllerListItemsV1Execute(r)
}

/*
CollectionsControllerListItemsV1 Method for CollectionsControllerListItemsV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCollectionsControllerListItemsV1Request
*/
func (a *CollectionsAPIService) CollectionsControllerListItemsV1(ctx context.Context, id string) ApiCollectionsControllerListItemsV1Request {
	return ApiCollectionsControllerListItemsV1Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListCollectionItemsDto
func (a *CollectionsAPIService) CollectionsControllerListItemsV1Execute(r ApiCollectionsControllerListItemsV1Request) (*ListCollectionItemsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListCollectionItemsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.CollectionsControllerListItemsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{id}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	} else {
		var defaultValue string = "createdAt_DESC"
		r.orderBy = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue float32 = 50
		r.limit = &defaultValue
	}
	if r.kind != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kind", r.kind, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCollectionsControllerRemoveItemsV1Request struct {
	ctx context.Context
	ApiService CollectionsAPI
	id string
	removeItemsFromCollectionControllerParamsDto *RemoveItemsFromCollectionControllerParamsDto
}

func (r ApiCollectionsControllerRemoveItemsV1Request) RemoveItemsFromCollectionControllerParamsDto(removeItemsFromCollectionControllerParamsDto RemoveItemsFromCollectionControllerParamsDto) ApiCollectionsControllerRemoveItemsV1Request {
	r.removeItemsFromCollectionControllerParamsDto = &removeItemsFromCollectionControllerParamsDto
	return r
}

func (r ApiCollectionsControllerRemoveItemsV1Request) Execute() (*http.Response, error) {
	return r.ApiService.CollectionsControllerRemoveItemsV1Execute(r)
}

/*
CollectionsControllerRemoveItemsV1 Method for CollectionsControllerRemoveItemsV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCollectionsControllerRemoveItemsV1Request
*/
func (a *CollectionsAPIService) CollectionsControllerRemoveItemsV1(ctx context.Context, id string) ApiCollectionsControllerRemoveItemsV1Request {
	return ApiCollectionsControllerRemoveItemsV1Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *CollectionsAPIService) CollectionsControllerRemoveItemsV1Execute(r ApiCollectionsControllerRemoveItemsV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.CollectionsControllerRemoveItemsV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{id}/items/remove"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeItemsFromCollectionControllerParamsDto == nil {
		return nil, reportError("removeItemsFromCollectionControllerParamsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeItemsFromCollectionControllerParamsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCollectionsControllerUpdateMetadataV1Request struct {
	ctx context.Context
	ApiService CollectionsAPI
	id string
	updateMetadataDto *UpdateMetadataDto
}

func (r ApiCollectionsControllerUpdateMetadataV1Request) UpdateMetadataDto(updateMetadataDto UpdateMetadataDto) ApiCollectionsControllerUpdateMetadataV1Request {
	r.updateMetadataDto = &updateMetadataDto
	return r
}

func (r ApiCollectionsControllerUpdateMetadataV1Request) Execute() (*ResourceEntity, *http.Response, error) {
	return r.ApiService.CollectionsControllerUpdateMetadataV1Execute(r)
}

/*
CollectionsControllerUpdateMetadataV1 Method for CollectionsControllerUpdateMetadataV1

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiCollectionsControllerUpdateMetadataV1Request
*/
func (a *CollectionsAPIService) CollectionsControllerUpdateMetadataV1(ctx context.Context, id string) ApiCollectionsControllerUpdateMetadataV1Request {
	return ApiCollectionsControllerUpdateMetadataV1Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResourceEntity
func (a *CollectionsAPIService) CollectionsControllerUpdateMetadataV1Execute(r ApiCollectionsControllerUpdateMetadataV1Request) (*ResourceEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CollectionsAPIService.CollectionsControllerUpdateMetadataV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/collections/{id}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateMetadataDto == nil {
		return localVarReturnValue, nil, reportError("updateMetadataDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMetadataDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
